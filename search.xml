<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CentOS 安装 Oracle 11g</title>
      <link href="/oracle/oracle_install.html"/>
      <url>/oracle/oracle_install.html</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载并解压-Oracle-的软件包"><a href="#下载并解压-Oracle-的软件包" class="headerlink" title="下载并解压 Oracle 的软件包"></a>下载并解压 Oracle 的软件包</h3><ul><li><p>下载</p></li><li><p><a href="https://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html" target="_blank" rel="noopener">oracle 下载地址</a></p></li><li><p>本文安装的是 Oracle Database 11g Release 2，分别下载两个压缩包,可以通过 ftp 上传至服务器</p><ul><li>linux.x64_11gR2_database_1of2.zip</li><li>linux.x64_11gR2_database_2of2.zip</li></ul></li><li><p>解压<br>切换到 oracle 压缩包目录，进行解压操作</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 解压oracle压缩文件到 /oracle</span><br><span class="line">su - root</span><br><span class="line">mkdir /oracle</span><br><span class="line">unzip -d /oracle linux.x64_11gR2_database_1of2.zip</span><br><span class="line">unzip -d /oracle linux.x64_11gR2_database_2of2.zip</span><br></pre></td></tr></table></figure></li></ul><p>若没有安装 unzip, 可以使用 <code>yum install unzip –y</code> 解压出来的文件到放置在当前 /oracle/database 目录下</p><h3 id="检查依赖"><a href="#检查依赖" class="headerlink" title="检查依赖"></a>检查依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line"></span><br><span class="line">rpm -q --qf &apos;%&#123;NAME&#125;-%&#123;VERSION&#125;-%&#123;RELEASE&#125;(%&#123;ARCH&#125;)\n&apos; binutils \</span><br><span class="line">elfutils-libelf \</span><br><span class="line">elfutils-libelf-devel \</span><br><span class="line">gcc \</span><br><span class="line">gcc-c++ \</span><br><span class="line">glibc \</span><br><span class="line">glibc-common \</span><br><span class="line">glibc-devel \</span><br><span class="line">glibc-headers \</span><br><span class="line">ksh \</span><br><span class="line">libaio \</span><br><span class="line">libaio-devel \</span><br><span class="line">libgcc \</span><br><span class="line">libstdc++ \</span><br><span class="line">libstdc++-devel \</span><br><span class="line">make \</span><br><span class="line">sysstat \</span><br><span class="line">unixODBC \</span><br><span class="line">unixODBC-devel | grep &quot;not installed&quot;</span><br></pre></td></tr></table></figure><p>若发现依赖没有安装，则使用 yum install 安装相应依赖</p><h3 id="修改-hostname"><a href="#修改-hostname" class="headerlink" title="修改 hostname"></a>修改 hostname</h3><p>参考: <a href="https://blog.csdn.net/tantexian/article/details/45958275" target="_blank" rel="noopener">https://blog.csdn.net/tantexian/article/details/45958275</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line"></span><br><span class="line"># 同时修改所有三个主机名：静态、瞬态和灵活主机名 </span><br><span class="line">hostnamectl set-hostname centos.java</span><br><span class="line"></span><br><span class="line"># 手动更新/etc/hosts  </span><br><span class="line">sudo vim /etc/hosts</span><br><span class="line">127.0.0.1  localhost centos.java</span><br><span class="line"></span><br><span class="line"># 重启 centos</span><br><span class="line">shutdown -r now</span><br><span class="line">reboot -f</span><br><span class="line"></span><br><span class="line"># 测试 hostname</span><br><span class="line">hostname</span><br><span class="line">ping -c 1 centos.java</span><br></pre></td></tr></table></figure><h3 id="SELINUX-和防火墙授权"><a href="#SELINUX-和防火墙授权" class="headerlink" title="SELINUX 和防火墙授权"></a>SELINUX 和防火墙授权</h3><ul><li><p>方式一:  手动添加端口授权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line"></span><br><span class="line"># 检查当前 linux 为 oracle 开启的端口</span><br><span class="line">semanage port -l | grep oracle</span><br><span class="line"></span><br><span class="line"># 若没有开放端口，则添加规则</span><br><span class="line">semanage port -a -t ssh_port_t -p tcp 1521</span><br><span class="line"></span><br><span class="line"># 检查 linux 防火墙是否已暴露端口</span><br><span class="line">firewall-cmd --permanent --list-port</span><br><span class="line"></span><br><span class="line"># 若防火墙没有开放对应端口，则开启</span><br><span class="line">firewall-cmd --zone=public --add-port=1521/tcp --permanent</span><br><span class="line"></span><br><span class="line"># 重载防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>方式二: 也可以关闭 selinux 与防火墙，若未关闭，则使用以下操作</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关闭 selinux </span><br><span class="line">vim /etc/selinux/config</span><br><span class="line"># 添加 SELINUX=disabled  ，若有SELINUX则将值设置成disabled</span><br><span class="line"></span><br><span class="line"># 关闭防火墙  </span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建-Oracle-用户和用户组"><a href="#创建-Oracle-用户和用户组" class="headerlink" title="创建 Oracle 用户和用户组"></a>创建 Oracle 用户和用户组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line"># 新建用户组</span><br><span class="line">groupadd oinstall </span><br><span class="line">groupadd dba</span><br><span class="line">groupadd oper</span><br><span class="line"> </span><br><span class="line"> # 新建用户</span><br><span class="line"> # -g：加入主要组、-G：加入次要组 、-M：不要自动建立用户的登入目录 -s&lt;shell&gt;：指定用户登入后所使用的shell</span><br><span class="line">useradd oracle -g oinstall -G dba,oper</span><br><span class="line"></span><br><span class="line"># 设置oracle用户的密码</span><br><span class="line">passwd oracle    </span><br><span class="line"> # 这里我使用的密码是 oracle</span><br><span class="line"> # 检查用户</span><br><span class="line"> id oracle</span><br><span class="line"> # uid=1001(oracle) gid=1001(oinstall) 组=1001(oinstall),1002(dba),1003(oper) 表示创建用户成功</span><br></pre></td></tr></table></figure><h3 id="创建-Oracle-安装目录和设置文件权限"><a href="#创建-Oracle-安装目录和设置文件权限" class="headerlink" title="创建 Oracle 安装目录和设置文件权限"></a>创建 Oracle 安装目录和设置文件权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line">mkdir -p /db/app/oracle</span><br><span class="line"></span><br><span class="line"># Oracle 数据文件存放位置</span><br><span class="line">mkdir -p /db/app/oracle/data</span><br><span class="line"></span><br><span class="line"># Oracle 安装日志存放位置</span><br><span class="line">mkdir -p /db/app/oracle/inventory</span><br><span class="line"></span><br><span class="line"># Oracle 快速恢复区</span><br><span class="line">mkdir -p  /db/app/oracle/fast_recovery_area</span><br><span class="line"></span><br><span class="line">chown -R oracle:oinstall  /db/app/oracle</span><br><span class="line">chmod  775  /db/app/oracle</span><br></pre></td></tr></table></figure><h3 id="设置-Oracle-用户环境变量"><a href="#设置-Oracle-用户环境变量" class="headerlink" title="设置 Oracle 用户环境变量"></a>设置 Oracle 用户环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 切换到 oracle 用户，修改配置</span><br><span class="line"># 注意，切换用户时切记要加 &quot;-&quot;，加 &quot;-&quot; 会拥有目标用户的环境变量，不加 &quot;-&quot; 则没有</span><br><span class="line">su - oracle </span><br><span class="line"># 密码是之前设置的，我这里设置的是 oracle</span><br></pre></td></tr></table></figure><ul><li>添加配置 <code>vim  ~/.bash_profile</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Oracle Settings</span><br><span class="line">export TMP=/tmp</span><br><span class="line">umask 022</span><br><span class="line"></span><br><span class="line">export ORACLE_HOSTNAME=centos.java</span><br><span class="line">export ORACLE_BASE=/db/app/oracle</span><br><span class="line">export ORACLE_HOME=$ORACLE_BASE/product/11.2.0</span><br><span class="line"># 数据库实例名</span><br><span class="line">export ORACLE_SID=orcl  </span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$ORACLE_HOME/bin</span><br></pre></td></tr></table></figure><p><code>source ~/.bash_profile</code> 使配置生效</p><h3 id="修改内核参数"><a href="#修改内核参数" class="headerlink" title="修改内核参数"></a>修改内核参数</h3><p><code>su - root</code> 修改 /etc/sysctl.conf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel.shmmni = 2048 </span><br><span class="line"># kernel.shmmax 是单个共享内存段的最大值，一般设置为本机物理内存 的一半，单位为 byte,比如物理内存是16G，这个值就是8G *1024 * 1024 * 1024=1073741824</span><br><span class="line">kernel.shmmax = 1073741824</span><br><span class="line"># kernel.shmall 配置物理内存的四分之一，单位是 k, 比如物理内存是16G，这个值就是4G*1024*1024=4194304</span><br><span class="line">kernel.shmall = 524288</span><br><span class="line">kernel.sem = 250 32000 100 128</span><br><span class="line"></span><br><span class="line">fs.aio-max-nr = 1048576</span><br><span class="line">fs.file-max = 6815744</span><br><span class="line">net.ipv4.ip_local_port_range = 9000 65500</span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.rmem_max = 4194304</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.wmem_max = 1048586</span><br></pre></td></tr></table></figure><p>使新内核配置生效 <code>/sbin/sysctl -p</code></p><h3 id="修改用户限制文件"><a href="#修改用户限制文件" class="headerlink" title="修改用户限制文件"></a>修改用户限制文件</h3><ul><li><p>操作身份 <code>su - root</code></p></li><li><p>限制 Oracle用户的 shell 权限 <code>vim /etc/security/limits.conf</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oracle      soft          nproc         2047</span><br><span class="line">oracle      hard        nproc         16384</span><br><span class="line">oracle      soft          nofile         1024</span><br><span class="line">oracle      hard        nofile         65536</span><br><span class="line">oracle      soft          stack          10240</span><br></pre></td></tr></table></figure></li><li><p>修改 /etc/pam.d/login 文件 <code>vim /etc/pam.d/login</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session  required   /lib64/security/pam_limits.so</span><br><span class="line">session  required   pam_limits.so</span><br></pre></td></tr></table></figure></li><li><p>修改  /etc/profile 文件<code>vim /etc/profile</code> (unset i 和 unset -f pathmunge 之前) 追加下面配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ $USER = &quot;oracle&quot; ]; then</span><br><span class="line">    if [ $SHELL = &quot;/bin/ksh&quot; ]; then</span><br><span class="line">        ulimit -p 16384</span><br><span class="line">        ulimit -n 65536</span><br><span class="line">    else</span><br><span class="line">        ulimit -u 16384 -n 65536</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><p>保存后，执行 <code>source /etc/profile</code></p><h2 id="安装-Oracle"><a href="#安装-Oracle" class="headerlink" title="安装 Oracle"></a>安装 Oracle</h2><p>切换到 oracle 解压包目录 <code>cd /oracle/database</code></p><h3 id="图形安装-Oracle"><a href="#图形安装-Oracle" class="headerlink" title="图形安装 Oracle"></a>图形安装 Oracle</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可以启动oracle图形界面安装向导</span><br><span class="line">cd /oracle/database</span><br><span class="line">./runInstall</span><br></pre></td></tr></table></figure><h3 id="命令行安装-Oracle"><a href="#命令行安装-Oracle" class="headerlink" title="命令行安装 Oracle"></a>命令行安装 Oracle</h3><ul><li><p>备份文件<br><code>cp  /oracle/database/response/db_install.rsp  /oracle/database/response/db_install.rsp.bak</code></p></li><li><p>编辑静默安装响应文件<br><code>vim /oracle/database/response/db_install.rsp</code></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装类型</span><br><span class="line">oracle.install.option=INSTALL_DB_SWONLY</span><br><span class="line"># 设置安全更新(填 true，否则会无限提醒邮件地址有问题，终止安装)</span><br><span class="line">DECLINE_SECURITY_UPDATES=true</span><br><span class="line">#  安装组</span><br><span class="line">UNIX_GROUP_NAME=oinstall</span><br><span class="line">INVENTORY_LOCATION=/db/app/oracle/inventory</span><br><span class="line">SELECTED_LANGUAGES=en,zh_CN</span><br><span class="line">ORACLE_HOSTNAME=centos.java</span><br><span class="line">ORACLE_HOME=/db/app/oracle/product/11.2.0</span><br><span class="line">ORACLE_BASE=/db/app/oracle</span><br><span class="line"># oracle版本</span><br><span class="line">oracle.install.db.InstallEdition=EE</span><br><span class="line">#自定义安装，否 false，使用默认组件</span><br><span class="line">oracle.install.db.isCustomInstall=true</span><br><span class="line">oracle.install.db.DBA_GROUP=dba</span><br><span class="line">oracle.install.db.OPER_GROUP=dba</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>开始安装</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 切换身份</span><br><span class="line">su - oracle</span><br><span class="line"># 切换到软件解压包目录</span><br><span class="line">cd /oracle/database </span><br><span class="line"></span><br><span class="line"># ./runInstaller -force -silent -noconfig -responseFile  /oracle/database/response/db_install.rsp  </span><br><span class="line"></span><br><span class="line">./runInstaller -silent -ignorePrereq -responseFile /oracle/database/response/db_install.rsp </span><br><span class="line"></span><br><span class="line"># 安装期间可以使用tail命令监看oracle的安装日志</span><br><span class="line">tail -f /db/app/oracle/inventory/logs/installActions201*.log</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>执行配置脚本(新开一个终端窗口)</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line">sh /db/app/oracle/inventory/orainstRoot.sh</span><br><span class="line">sh /db/app/oracle/product/11.2.0/root.sh</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>返回之前的终端窗口 按 “Enter” 键继续, 安装完成，提示 Successfully Setup Software</p></li><li><p>配置静默监听</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - oracle</span><br><span class="line">netca -silent -responsefile   /oracle/database/response/netca.rsp</span><br><span class="line"># 执行上述命令可能会遇到错误</span><br><span class="line">解决方式: export  DISPLAY=172.20.1.1:1.0</span><br><span class="line">再次执行 netca -silent -responsefile   /oracle/database/response/netca.rsp</span><br><span class="line"># 查看1521端口是否在监听中</span><br><span class="line">netstat -tnulp | grep 1521</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建数据库(静默方式建立新库，同时也建立一个对应的实例)<br>  修改配置文件 切换身份 <code>su - oracle</code> 然后执行 <code>vim /oracle/database/response/dbca.rsp</code>，配置参考如下</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GDBNAME= &quot;orcl&quot;</span><br><span class="line">SID =&quot;orcl&quot;</span><br><span class="line">SYSPASSWORD= &quot;oracle&quot;</span><br><span class="line">SYSTEMPASSWORD= &quot;oracle&quot;</span><br><span class="line">SYSMANPASSWORD= &quot;oracle&quot;</span><br><span class="line">DBSNMPPASSWORD= &quot;oracle&quot;</span><br><span class="line">DATAFILEDESTINATION=/db/app/oracle/data</span><br><span class="line">RECOVERYAREADESTINATION=/db/app/oracle/fast_recovery_area</span><br><span class="line">CHARACTERSET= &quot;AL32UTF8&quot;</span><br><span class="line"># 单位为 MB，一般设置为物理内存的80%</span><br><span class="line">TOTALMEMORY= &quot;1638&quot;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>执行建库操作    </p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbca  -silent  -createDatabase   -responseFile  /oracle/database/response/dbca.rsp     </span><br><span class="line">可以新开一个窗口 tail -f /db/app/oracle/cfgtoollogs/dbca/orcl/orcl.log 查看操作日志</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>验证安装</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看oracle实例进程</span><br><span class="line">ps -ef | grep ora_ | grep -v grep</span><br><span class="line"></span><br><span class="line"># 查看监听状态</span><br><span class="line">lsnrctl status</span><br><span class="line"></span><br><span class="line"># 关闭监听</span><br><span class="line"># lsnrctl stop</span><br><span class="line"></span><br><span class="line"># 开启监听</span><br><span class="line"># lsnrctl start</span><br><span class="line"></span><br><span class="line"># 登录 sqlplus 查看实例状态</span><br><span class="line">sqlplus / as sysdba</span><br><span class="line">select status from v$instance;</span><br><span class="line"></span><br><span class="line"># 使用 dba 权限连接 Oracle</span><br><span class="line"># connect / as sysdba</span><br><span class="line"></span><br><span class="line"># 关闭数据库服务</span><br><span class="line">#shutdown immediate;</span><br><span class="line"></span><br><span class="line"># 开启数据库服务, 遇到环境变量的问题，参考 https://blog.51cto.com/fuwenchao/1361135</span><br><span class="line">startup;</span><br><span class="line"></span><br><span class="line"># 退出管理员</span><br><span class="line">quit；或 exit;</span><br><span class="line"></span><br><span class="line"># 查看数据库编码</span><br><span class="line">select userenv(&apos;language&apos;) from dual;</span><br><span class="line"></span><br><span class="line"># 查看数据库版本信息</span><br><span class="line">select * from v$version;</span><br><span class="line"></span><br><span class="line"># 激活 scott 用户</span><br><span class="line">alter user scott account unlock;</span><br><span class="line">alter user scott identified by tiger;</span><br><span class="line">select * from all_users;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Oracle-开机自启动设置"><a href="#Oracle-开机自启动设置" class="headerlink" title="Oracle 开机自启动设置"></a>Oracle 开机自启动设置</h2><ul><li>修改 /db/app/oracle/product/11.2.0/bin/dbstart<br>将 ORACLE_HOME_LISTNER=$1 修改为 <code>ORACLE_HOME_LISTNER=$ORACLE_HOME</code></li></ul><ul><li><p>修改 /db/app/oracle/product/11.2.0/bin/dbshut<br>将 ORACLE_HOME_LISTNER=$1 修改为 <code>ORACLE_HOME_LISTNER=$ORACLE_HOME</code></p></li><li><p>修改 /etc/oratab 文件<br>将 orcl:/db/app/oracle/product/11.2.0:N 中最后的 N 改为 Y，成为 <code>orcl:/db/app/oracle/product/11.2.0:Y</code></p></li><li><p>输入 dbshut 和 dbstart 测试<br><code>dbshut</code> (Oracle 监听停止，进程消失)<br><code>dbstart</code> (Oracle监听启动，进程启动)</p></li><li><p>切换到 root 账户建立自启动脚本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line">vi /etc/rc.d/init.d/oracle</span><br></pre></td></tr></table></figure></li><li><p>添加以下内容（有些值如 ORACLE_HOME 和 ORACLE_USER 等根据实际情况可以修改）</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"># oracle: Start/Stop Oracle Database 11g R2</span><br><span class="line">#</span><br><span class="line"># chkconfig: 345 90 10</span><br><span class="line"># description: The Oracle Database is an Object-Relational Database Management System.</span><br><span class="line">#</span><br><span class="line"># processname: oracle</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line">LOCKFILE=/var/lock/subsys/oracle</span><br><span class="line">ORACLE_HOME=/db/app/oracle/product/11.2.0</span><br><span class="line">ORACLE_USER=oracle</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">&apos;start&apos;)</span><br><span class="line">   if [ -f $LOCKFILE ]; then</span><br><span class="line">      echo $0 already running.</span><br><span class="line">      exit 1</span><br><span class="line">   fi</span><br><span class="line">   echo -n $&quot;Starting Oracle Database:&quot;</span><br><span class="line">   su - $ORACLE_USER -c &quot;$ORACLE_HOME/bin/lsnrctl start&quot;</span><br><span class="line">   su - $ORACLE_USER -c &quot;$ORACLE_HOME/bin/dbstart $ORACLE_HOME&quot;</span><br><span class="line">   su - $ORACLE_USER -c &quot;$ORACLE_HOME/bin/emctl start dbconsole&quot;</span><br><span class="line">   touch $LOCKFILE</span><br><span class="line">   ;;</span><br><span class="line">&apos;stop&apos;)</span><br><span class="line">   if [ ! -f $LOCKFILE ]; then</span><br><span class="line">      echo $0 already stopping.</span><br><span class="line">      exit 1</span><br><span class="line">   fi</span><br><span class="line">   echo -n $&quot;Stopping Oracle Database:&quot;</span><br><span class="line">   su - $ORACLE_USER -c &quot;$ORACLE_HOME/bin/lsnrctl stop&quot;</span><br><span class="line">   su - $ORACLE_USER -c &quot;$ORACLE_HOME/bin/dbshut&quot;</span><br><span class="line">   su - $ORACLE_USER -c &quot;$ORACLE_HOME/bin/emctl stop dbconsole&quot;</span><br><span class="line">   rm -f $LOCKFILE</span><br><span class="line">   ;;</span><br><span class="line">&apos;restart&apos;)</span><br><span class="line">   $0 stop</span><br><span class="line">   $0 start</span><br><span class="line">   ;;</span><br><span class="line">&apos;status&apos;)</span><br><span class="line">   if [ -f $LOCKFILE ]; then</span><br><span class="line">      echo $0 started.</span><br><span class="line">      else</span><br><span class="line">      echo $0 stopped.</span><br><span class="line">   fi</span><br><span class="line">   ;;</span><br><span class="line">*)</span><br><span class="line">   echo &quot;Usage: $0 [start|stop|status]&quot;</span><br><span class="line">   exit 1</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>设置为开机启动</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable oracle</span><br><span class="line"># 修改 /etc/init.d/oracle 服务文件权限</span><br><span class="line"># chmod 755 /etc/init.d/oracle</span><br><span class="line"># chkconfig oracle on</span><br></pre></td></tr></table></figure></li><li><p>进行 service oracle start/stop/restart 测试</p></li><li><p>reboot 重启查看 Oracle 监听和实例进程均能自动启动</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看1521端口是否在监听中</span><br><span class="line">netstat -tnulp | grep 1521</span><br><span class="line"># 查看oracle实例进程</span><br><span class="line">ps -ef | grep ora_ | grep -v grep</span><br></pre></td></tr></table></figure></li><li><p>开机启动问题：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># oracle ORA-12547: TNS:lost contact</span><br><span class="line"># 解决方法</span><br><span class="line">cd /db/app/oracle/product/11.2.0/bin/</span><br><span class="line">chmod 6751 oracle</span><br><span class="line"></span><br><span class="line"># TNS-12555: TNS:permission denied</span><br><span class="line"># 解决方法</span><br><span class="line">cd /var/tmp</span><br><span class="line">chown -R oracle:oinstall .oracle</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务管理</title>
      <link href="/java/spring_tx.html"/>
      <url>/java/spring_tx.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p><strong>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。</strong></p><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性(Atomicity) : 整个事务中的所有操作要么全部提交成功，要么全部失败回滚。</li><li>一致性(Consistency) : 数据库总是从一个一致性的状态转换到另一个一致性的状态。 </li><li>隔离性(Isolation) : 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li><li>持久性(Durability) : 一旦事务提交，则其所做的修改就会永久保存到数据库中。<a id="more"></a></li></ul><h3 id="SQL-中的事务隔离级别"><a href="#SQL-中的事务隔离级别" class="headerlink" title="SQL 中的事务隔离级别"></a>SQL 中的事务隔离级别</h3><p><strong>SQL 标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低的隔离通常可以执行更高的并发，系统的开销也更低。</strong></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>READ UNCOMMITED(未提交读)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>READ COMMITED(提交读)</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>REPEATABLE READ(可重复读)</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>SERIALIZABLE(可串行化)</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><h4 id="幻读与不可重复读的区别"><a href="#幻读与不可重复读的区别" class="headerlink" title="幻读与不可重复读的区别"></a>幻读与不可重复读的区别</h4><p><strong>幻读</strong>的重点在于<strong>插入与删除</strong>，即第二次查询会发现比第一次查询数据变少或者变多了，以至于给人一种幻象一样，而<strong>不可重复读</strong>重点在于<strong>修改</strong>，即第二次查询会发现查询结果比第一次查询结果不一致，即第一次结果已经不可重现了。</p><p>脏读、不可重复读、幻读的简单例子</p><ol><li>一个事务A 根据条件查询得到的结果集为 1000 条数据，同时另外一个事务 B 插入或删除了事务 A 结果集中的数据，比如删除一条数据，导致事务 A 使用同样的查询条件再次查询时，结果集的数目变少了，这时候事务A 就迷惑了，这就是出现了幻读的现象。</li><li>一个事务 A 读取数据库中的一条记录，同时另外一个事务 B 修改了事务 A 读取到的那条记录，导致事务 A 再次读取同一条记录时发生了变化，这就是发生了不可重复读的现象。</li><li>脏读就是事务 A 读取到了另外一个事务B 未提交事务的数据。</li></ol><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><p><strong>Spring 事务管理就是通过 Java 代码去实现对数据库的事务性操作，以确保其满足 ACID 原则。</strong></p><h3 id="事务的类型"><a href="#事务的类型" class="headerlink" title="事务的类型"></a>事务的类型</h3><ol><li>数据库层面划分<ul><li>本地事务 :  独立的一个数据库</li><li>分布式事务 : 涉及两个或多个数据库的事务</li></ul></li><li>Java 事务的类型<ul><li>JDBC 事务 :  只能处理本地事务(即一个数据库内的事务操作)，通过 <code>connection</code> 对象管理控制。</li><li>JTA 事务 : Java 事务 API(Java Transaction API)，高层的，与实现无关，与协议无关的 API,<strong>支持分布式事务，</strong>可跨域多个数据库或多个 Dao。</li><li>容器事务 : J2EE 应用服务器提供的事务管理，大多数是基于 JTA 事务，局限于 EJB 应用使用。</li></ul></li></ol><h3 id="事务核心接口"><a href="#事务核心接口" class="headerlink" title="事务核心接口"></a>事务核心接口</h3><p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器，Spring 将事务管理的职责委托给 JDBC 、Hibernate、JPA 或 JTA 等提供了持久化机制的框架来实现。</strong></p><ul><li><strong>PlatformTransactionManager</strong>:  事务管理器接口</li><li><strong>TransactionDefinition</strong> : 事务属性定义接口(事务的传播行为、隔离级别、超时、只读、回滚规则)</li><li><strong>TransactionStatus</strong> : 事务运行状态接口</li></ul><p><img src="https://images.csthink.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-20%2012.40.59.png" alt="Spring 事务接口架构"></p><h4 id="事务管理器接口-PlatformTransactionManager"><a href="#事务管理器接口-PlatformTransactionManager" class="headerlink" title="事务管理器接口( PlatformTransactionManager )"></a>事务管理器接口( PlatformTransactionManager )</h4><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2014.49.22.png" alt="事务管理器接口"></p><p>Spring 内置的事务管理器都继承了 <strong>AbstractPlatformTransactionManager</strong>,而 <strong>AbstractPlatformTransactionManager</strong> 又实现了<strong>PlatformTransactionManager</strong> 接口。<br>Spring 框架支持事务管理的核心是事务管理器抽象，对于不同的数据访问框架通过实现策略接口<strong>PlatformTransactionManager</strong>，从而使得 Spring 能支持多种数据访问框架的事务管理。</p><ul><li><p><strong>DataSourceTransactionManager</strong>  :  <code>org.springframework.jdbc.datasource</code> 包提供，通过调用 <code>java.sql.Connection</code> 提供对单个 <code>javax.sql.DataSource</code> 数据源的事务管理，只用于 JDBC , MyBatis 框架的事务管理。</p><p>  <strong>在使用 JDBC 或 MyBatis 时，XML的参考配置:</strong>   </p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/dbName?useUnicode=true&amp;amp;characterEncoding=utf-8"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>HibernateTransactionManager</strong> : <code>org.springframework.orm.hibernate3</code> 包提供，通过将事务管理的职责委托给 <code>org.hibernate.Transaction</code> 对象来提供对单个 <code>org.hibernate.SessionFactory</code> 的事务管理，该事务管理器只支持 Hibernate3+ 版本，且Spring3.0+ 版本只支持 Hibernate 3.2+ 版本。</li><li><strong>JpaTransactionManager</strong>  :  <code>org.springframework.orm.jpa</code> 包提供，通过一个 JPA 实体管理工厂(<code>javax.persistence.EntityManagerFactory</code> 接口的任意实现)，与由工厂所产生的 JPA EntityManager 合作来管理事务。</li><li><strong>JtaTransactionManger</strong> : <code>org.springframework.transaction.jta</code> 包提供，通过将事务管理的责任委托给 <code>javax.transaction.UserTransaction</code> 和 <code>javax.transaction.TransactionManager</code> 对象来进行事务的管理。</li></ul><h4 id="事务属性定义接口-TransactionDefinition"><a href="#事务属性定义接口-TransactionDefinition" class="headerlink" title="事务属性定义接口( TransactionDefinition )"></a>事务属性定义接口( TransactionDefinition )</h4><p>事务管理器接口 *<em>PlatformTransactionManager *</em> 通过 <code>getTransaction(TransactionDefinition definition)</code> 方法来获取一个事务，该方法的参数是 <code>TransactionDefinition</code> 类型 ，这个类中定义了事务的属性。</p><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2014.13.44.png" alt="事务属性定义接口"></p><h5 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h5><p><strong>当事务方法被另一个事务方法调用时(事务嵌套的使用)，必须指定事务应该如何传播，有7种传播行为</strong></p><ol><li><strong>PROPAGATION_REQUIRED</strong> : 表示当前事务必须运行在事务中，如果当前存在事务，方法将会在该事务中运行，否则会启动一个新的事务。</li><li><strong>PROPAGATION_SUPPORTS</strong> : 表示当前方法不需要事务上下文，但是若存在当前事务的话，那么该方法会在这个事务中运行。</li><li><strong>PROPAGATION_MANDATORY</strong> : 表示该方法必须在事务中运行，如果当前不存在事务，则会抛出一个异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong> : 表示当前方法必须运行在它自己的事务中。如果当前存在事务，则会启动一个新的事务，若当前使用 JTATransactionManager 的话，在该方法执行期间，则需要访问 TransactionManager。</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong> : 表示该方法不应该运行在事务中，如果当前存在事务，在该方法运行期间，当前事务将被挂起。若当前使用 JTATransactionManager 的话，在该方法执行期间，则需要访问 TransactionManager。</li><li><strong>PROPAGATION_NEVER</strong> : 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。</li><li><strong>PROPAGATION_NESTED</strong> : 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行，嵌套的食物可以独立于当前事务进行单独的提交会回滚。如果当前不存在事务，那么其行为与 PROPAGATION_REQUIRED 一样，注意各数据库厂商对这种传播行为的支持是有差异的，可以参考各资源管理器的文档来确认是否支持嵌套事务。</li></ol><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>Spring 有5种隔离级别，默认的是 ISOLATION_DEFAULT(使用数据库的默认隔离级别)，其他四种隔离级别与数据库的隔离级别一致。</p><ul><li>ISOLATION_DEFAULT</li><li>ISOLATION_READ_UNCOMMITTED</li><li>ISOLATION_READ_COMMITTED</li><li>ISOLATION_REPEATABLE_READ</li><li>ISOLATION_SERIALIZABLE</li></ul><h5 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h5><p>指一事务所允许执行的最长时间，单位是秒，若在指定时间内没有执行完毕，那么事务就会自动回滚。长时间的事务会不必要的占用数据库资源。</p><h5 id="事务是否只读属性"><a href="#事务是否只读属性" class="headerlink" title="事务是否只读属性"></a>事务是否只读属性</h5><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。</p><ul><li>事务的是否 “只读” 属性，不同的数据库厂商支持不同</li><li>Oracle 的 “readOnly” 不起作用，不影响其 CRUD</li><li>MySQL 的 “readOnly” 为 true, 只能查，增删改则出异常</li></ul><h5 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h5><p>默认情况下，事务只有遇到运行期异常才会回滚，而在遇到检查型异常时不会回滚。</p><ul><li>作用一 : 自定义策略使得事务在遇到检查型异常时会像运行期遇到异常那样处理事务回滚</li><li>作用二 : 声明事务遇到特定的异常不会回滚，即时是运行期遇到异常</li></ul><h4 id="事务运行状态接口-TransactionStatus"><a href="#事务运行状态接口-TransactionStatus" class="headerlink" title="事务运行状态接口( TransactionStatus )"></a>事务运行状态接口( TransactionStatus )</h4><p><strong>TransactionStatus</strong> 接口用来记录事务的状态，该接口中定义了一组方法，用来获取或判断事务的状态信息。事务管理器接口 <strong>PlatfromTransactionManager</strong> 调用 <code>getTransaction()</code> 方法会返回一个 <code>TransactionStatus</code>对象。</p><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2014.46.07.png" alt="事务运行状态接口"></p><h3 id="事务的实现方式"><a href="#事务的实现方式" class="headerlink" title="事务的实现方式"></a>事务的实现方式</h3><h4 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h4><p>所有的源码都托管在了 github 上 : <a href="https://github.com/csthink/SPRING-TX" target="_blank" rel="noopener">https://github.com/csthink/SPRING-TX</a> </p><h5 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h5><p>编程式事务我选择的是一个员工表，表结构如下<br><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2022.29.22.png" alt="employee 员工表"></p><p>声明式事务我使用的也是一个员工表和一个部门表，员工表用于测试 tx 拦截器实现声明式事务，部门表用于测试注解方式实现的声明式事务</p><p><img src="https://images.csthink.com/Carbonize%202019-04-21%20at%2008.13.34.png" alt="employee2 员工表"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-21%20at%2008.14.15.png" alt="department 部门表"></p><h5 id="java-文件"><a href="#java-文件" class="headerlink" title="java 文件"></a>java 文件</h5><p>这里准备了一个 Employee 表的实体文件，一个操作 Employee 表的 Dao 接口以及其实现类，还有一个相应的测试类文件</p><h5 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h5><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2022.23.50.png" alt="编程式事务依赖"></p><p>声明式事务依赖，需要在编程式事务依赖的基础上添加两个依赖，一个是 DBCP 数据库连接池的依赖，数据源配置的时候，可以不使用，也可以直接使用 C3P0 或直接使用 jdbc 的数据源配置即可，声明式事务的 tx 拦截器的方式需要配合 AOP 实现，所以需要添加 AspectJ 的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.csthink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring 基础依赖,包含了 spring-core spring-beans spring-aop spring-expression spring-tx --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MySQL 驱动支持 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- C3P0 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- DBCP 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring JDBC Template 所需的依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Junit 单元测试依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring 与 Junit 的整合 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring 基于 AspectJ 开发 AOP 的依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Spring-配置文件"><a href="#Spring-配置文件" class="headerlink" title="Spring 配置文件"></a>Spring 配置文件</h5><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2022.26.12.png" alt="编程式事务 xml 配置 Spring.xml"></p><h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><h5 id="使用事务管理器方式实现编程式事务-PlatformTransactionManager"><a href="#使用事务管理器方式实现编程式事务-PlatformTransactionManager" class="headerlink" title="使用事务管理器方式实现编程式事务 ( PlatformTransactionManager)"></a>使用事务管理器方式实现编程式事务 ( PlatformTransactionManager)</h5><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2022.54.54.png" alt="事务管理器方式"></p><h5 id="使用模板事务实现编程式事务-TransactionTemplate-推荐"><a href="#使用模板事务实现编程式事务-TransactionTemplate-推荐" class="headerlink" title="使用模板事务实现编程式事务( TransactionTemplate ) 推荐"></a>使用模板事务实现编程式事务( TransactionTemplate ) 推荐</h5><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2022.59.29.png" alt="模板事务方式"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-20%20at%2023.01.31.png" alt="测试类"></p><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>由于编程式事务每个需要事务的场景中都需要单独的实现，可复用性低，声明式事务属于无侵入式实现，声明式事务的实现方式常用的主要有两种方式: tx 拦截器以及全注解方式实现。</p><h5 id="使用-tx-拦截器方式实现声明式事务"><a href="#使用-tx-拦截器方式实现声明式事务" class="headerlink" title="使用 tx 拦截器方式实现声明式事务"></a>使用 tx 拦截器方式实现声明式事务</h5><p>这种方式，只需要在 Spring 的配置文件中配置即可，代码中不需要任何特殊处理，下面是一个 xml 配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring IOC 开启全局扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.csthink"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库连接属性配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"classpath:database.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据源配置使用 DBCP 数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp2.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdbcTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明式事务 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JDBC 事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务增强，通过事务通知的方式实现事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点中哪些方法需要过滤 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可选属性配置</span></span><br><span class="line"><span class="comment">              name:方法名称，将匹配的方法注入事务管理，可用通配符</span></span><br><span class="line"><span class="comment">              propagation:事务传播行为</span></span><br><span class="line"><span class="comment">              isolation:事务隔离级别，默认为“DEFAULT”</span></span><br><span class="line"><span class="comment">              read-only:是否只读，默认为 false，表示不是只读</span></span><br><span class="line"><span class="comment">              timeout:事务超时时间，单位为秒，默认 -1，表示事务超时将依赖于底层事务系统</span></span><br><span class="line"><span class="comment">              rollback-for:需要触发回滚的异常定义，可定义多个，以逗号","分割，默认任何 RuntimeException 都将导致事务回滚，而任何 Checked Exception 将不导致事务回滚</span></span><br><span class="line"><span class="comment">              no-rollback-for:不被触发进行回滚的 Exception(s)；可定义多个，以逗号","分割</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置进行事务操作的方法匹配规则 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 以 get/find/search 开头的所有方法设置为只读事务 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"search*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 其它方法使用默认事务设置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切面配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点配置: com.csthink.service 包下任意类任意个数的参数的方法都会被过滤 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.csthink.service.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通知与切入点关联 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用注解的方式实现声明式事务"><a href="#使用注解的方式实现声明式事务" class="headerlink" title="使用注解的方式实现声明式事务"></a>使用注解的方式实现声明式事务</h5><p>使用注解的方式实现事务，需要在 Spring 的 xml 配置文件中开启注解事务的声明，每个需要使用事务的类或方法上可以使用 <code>@Transactional</code> 注解即可</p><p>下面是使用注解方式实现声明式事务的配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring IOC 开启全局扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.csthink"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据源配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;amp;characterEncoding=utf8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdbcTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明式事务 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JDBC 事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启事务注解，通过事务注解的方式实现事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://images.csthink.com/Carbonize%202019-04-21%20at%2007.52.27.png" alt="@Transaction 用法"></p><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>可以在 github 上找到我关于 spring 事务的测试代码 : <a href="https://github.com/csthink/SPRING-TX" target="_blank" rel="noopener">https://github.com/csthink/SPRING-TX</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 基于 AspectJ 的 AOP 开发</title>
      <link href="/java/spring_aspectj.html"/>
      <url>/java/spring_aspectj.html</url>
      
        <content type="html"><![CDATA[<h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><ul><li>AspectJ 是一个面向切面的框架，Spring2.0以后新增了对 AspectJ 切点表达式的支持</li><li>@AspectJ 是 AspectJ 1.5 新增的功能，通过 JDK5 注解技术，允许直接在 Bean 类中定义切面</li><li>Spring 建议使用 AspectJ 方式来开发 AOP</li><li>使用 AspectJ 需要 Spring AOP 和 AspectJ 相关的 jar 包</li></ul><a id="more"></a><p>下面这个 maven 依赖配置是我接下来 Demo 中用到的依赖</p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2018.00.45.png" alt="Maven 依赖"></p><h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><h3 id="Spring-配置启用-AspectJ-切面注解"><a href="#Spring-配置启用-AspectJ-切面注解" class="headerlink" title="Spring 配置启用 @AspectJ 切面注解"></a>Spring 配置启用 @AspectJ 切面注解</h3><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2018.23.15.png" alt="Spring 配置文件"></p><h3 id="AspectJ-支持的通知-增强-类型"><a href="#AspectJ-支持的通知-增强-类型" class="headerlink" title="@AspectJ 支持的通知(增强)类型"></a>@AspectJ 支持的通知(增强)类型</h3><ul><li><code>@Before</code> 前置通知 —&gt; <code>BeforeAdvice</code></li><li><code>@AfterReturning</code> 后置通知 —&gt; <code>AfterReturningAdvice</code></li><li><code>@Around</code> 环绕通知 —&gt; <code>MethodInterceptor</code></li><li><code>@AfterThrowing</code> 异常抛出通知 —&gt; <code>ThrowAdvice</code></li><li><code>@After</code> 最终 final 通知，不管是否异常，该通知都会执行</li><li><code>@DeclareParents</code> 引介通知 —&gt; <code>IntroductionInterceptor</code></li></ul><h3 id="定义切面类"><a href="#定义切面类" class="headerlink" title="定义切面类"></a>定义切面类</h3><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2018.21.25.png" alt="定义切面类"></p><h3 id="在通知中通过-value-属性定义切入点"><a href="#在通知中通过-value-属性定义切入点" class="headerlink" title="在通知中通过 value 属性定义切入点"></a>在通知中通过 value 属性定义切入点</h3><p> <strong>通过 execution 函数，可以定义切入点的方法切入</strong></p><blockquote><p>语法: execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</p></blockquote><ul><li>匹配所有类的 public 方法 <code>execution(pubic **(..))</code></li><li>匹配指定包下所有的类所有的方法 <code>execution(* com.csthink.dao.*(..))</code> <strong>不包含子包</strong></li><li><code>execution(* com.csthink.dao..*(..))</code> <code>..*</code> 表示包、子孙包下所有类</li><li>匹配指定类所有的方法 <code>execution(* com.csthink.service.UserService.*(..))</code></li><li>匹配实现特定接口  <code>CommonDao</code> 的所有类中所有的方法 <code>execution(* com.csthink.dao.CommonDAO+.*(..))</code> <code>+</code> 表示子类</li><li>匹配所有 save 开头的方法 <code>execution(* save*(..))</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>该示例演示的是使用 AspectJ 注解方式开发 AOP，注解方式管理 Bean,涉及到几个文件分别是: </p><ul><li>Spring 的配置文件</li><li>业务层接口</li><li>业务层实现类</li><li>代理类(切面类)</li><li>测试类</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2019.09.36.png" alt="Spring 配置文件"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2019.10.05.png" alt="目标类-接口"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2019.10.26.png" alt="实现类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2021.31.54.png" alt="切面类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2021.39.09.png" alt="测试类"></p><p>测试结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前置通知----&gt;模拟权限校验...execution(void com.csthink.demo.demo1.UserService.save())</span><br><span class="line">保存用户操作...</span><br><span class="line">最终通知 ----&gt; 模拟记录日志...</span><br><span class="line">环绕前通知...</span><br><span class="line">删除用户操作...</span><br><span class="line">目标对象方法的返回值是: 用户删除成功</span><br><span class="line">环绕后通知...</span><br><span class="line">前置通知----&gt;模拟权限校验...execution(Integer com.csthink.demo.demo1.UserService.update())</span><br><span class="line">修改用户操作...</span><br><span class="line">后置通知: 10</span><br><span class="line">查询用户操作....</span><br><span class="line">异常抛出通知: / by zero</span><br></pre></td></tr></table></figure><h3 id="AspectJ-注解方式实现-AOP-开发小结"><a href="#AspectJ-注解方式实现-AOP-开发小结" class="headerlink" title="AspectJ 注解方式实现 AOP 开发小结"></a>AspectJ 注解方式实现 AOP 开发小结</h3><ul><li>切面类中使用 <code>@Pointcut</code>为切入点命名,可以减轻维护成本,通知多个切入点可以使用 <code>||</code> 进行连接，切入点方法是 private void 无参数方法</li></ul><h2 id="XML-方式"><a href="#XML-方式" class="headerlink" title="XML 方式"></a>XML 方式</h2><p>示例中的目标类接口以及接口实现类的代码结构都类似上面的例子，下面提供的是 Spring 的配置文件，切面类以及测试类</p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2022.02.57.png" alt="Spring 配置文件"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2022.02.12.png" alt="切面类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2022.03.35.png" alt="测试类"></p><p>测试结果与上面使用 AspectJ 注解方式实现 AOP 的结果类似</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前置通知----&gt;模拟权限校验...execution(void com.csthink.demo.demo2.EmployeeService.save())</span><br><span class="line">保存用户操作...</span><br><span class="line">最终通知 ----&gt; 模拟记录日志...</span><br><span class="line">环绕前通知</span><br><span class="line">删除用户操作...</span><br><span class="line">目标对象方法的返回值是: 用户删除成功</span><br><span class="line">环绕后通知</span><br><span class="line">前置通知----&gt;模拟权限校验...execution(Integer com.csthink.demo.demo2.EmployeeService.update())</span><br><span class="line">修改用户操作...</span><br><span class="line">后置通知10</span><br><span class="line">查询用户操作....</span><br><span class="line">异常抛出通知/ by zero</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP 入门篇</title>
      <link href="/java/spring_aop.html"/>
      <url>/java/spring_aop.html</url>
      
        <content type="html"><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p>面向切面编程（AOP，Aspect Oriented Programming），AOP 采取横向抽取机制，取代了传统纵向继承体系重复性代码，用于解耦业务代码和公共服务代码（如日志，安全，事务等）。软件开发中经常提一个词，叫做”业务逻辑”或者”业务功能”，我们的代码主要就是实现某种特定的业务逻辑。但是我们往往不能专注于业务逻辑，比如我们写业务逻辑代码的同时，还要关注事务管理、缓存、日志等一系列通用功能，如果每个业务功能都要和这些通用功能混在一起，是一件非常低效和痛苦的事情。所以，为了将业务功能的关注点和通用化功能的关注点分离开来，就需要 AOP 技术了。通用功能的代码实现，对应的就是我们说的切面（Aspect）, 简而言之，AOP就是一种在开发时将业务相关代码和业务无关的通用功能代码有机分离，而运行时又能够整合到一起形成完整功能的一整套技术</p></blockquote><a id="more"></a><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>当一个对象（客户端）不能或者不想直接引用另一个对象（目标对象），这时可以应用代理模式在这两者之间构建一个桥梁 – 代理对象</li><li>按照代理对象的创建时期不同，可以分为两种：<ul><li>静态代理: 程序中事先准备代理对象类，在程序发布前就已经存在了</li><li>动态代理: 应用程序发布后，通过动态创建代理对象(JDK/Cglib 动态代理)</li></ul></li></ul><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>下面是一个使用JDK动态代理的Demo,Demo 中包含了4个文件</p><ul><li>UserService 业务类接口</li><li>UserServiceImpl 业务类的实现类</li><li>UserServiceJdkProxy 业务类的代理类</li><li>TestUserService 测试类</li></ul><p><strong>注意,以下示例需要的 maven 依赖</strong><br><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2015.46.44.png" alt="maven 依赖"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2010.07.13.png" alt="接口"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2010.07.34.png" alt="实现类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2010.14.56.png" alt="JDK 动态代理类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2010.08.28.png" alt="测试类"></p><p>test1 执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加操作...</span><br><span class="line">删除操作...</span><br></pre></td></tr></table></figure><p>test2 执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加操作执行前: 权限校验....</span><br><span class="line">添加操作...</span><br><span class="line">添加操作执行后: 记录日志...</span><br><span class="line">删除操作...</span><br></pre></td></tr></table></figure><h5 id="JDK-实现动态代理小结"><a href="#JDK-实现动态代理小结" class="headerlink" title="JDK 实现动态代理小结"></a>JDK 实现动态代理小结</h5><ul><li><strong>代理对象和目标对象实现了相同的接口,目标对象作为代理对象的一个属性，具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑</strong></li><li><strong>需要指定具体的目标对象，如果为每个类都添加一个代理类的话，会导致类很多</strong></li><li><strong>JDK 动态代理只能针对实现了接口的类生成代理</strong></li></ul><h4 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h4><p> 下面是一个使用CGLIB动态代理的Demo,Demo 中包含了3个文件<br>    - StudentDao 持久层<br>    - StudentDaoCGLibProxy 持久层的代理类<br>    - TestStudentDao 测试类</p><p><strong>注意,以下示例需要的 maven 依赖</strong></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.19.46.png" alt="maven 依赖"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2010.43.51.png" alt="Dao 类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2011.04.50.png" alt="CGLIB 动态代理类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2011.05.18.png" alt="测试类"></p><p>test1 执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入学生记录</span><br><span class="line">删除学生记录</span><br></pre></td></tr></table></figure><p>test2 执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入学生记录</span><br><span class="line">删除操作执行前: 权限校验....</span><br><span class="line">删除学生记录</span><br><span class="line">删除操作执行后: 记录日志....</span><br></pre></td></tr></table></figure><h5 id="CGLib-实现动态代理小结"><a href="#CGLib-实现动态代理小结" class="headerlink" title="CGLib 实现动态代理小结"></a>CGLib 实现动态代理小结</h5><ul><li>CGLIB底层：使用字节码处理框架ASM，来转换字节码并生成新的类 </li><li>CGLIB（CODE GENERLIZE LIBRARY）代理是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称 final</li></ul><h2 id="AOP-相关术语说明"><a href="#AOP-相关术语说明" class="headerlink" title="AOP 相关术语说明"></a>AOP 相关术语说明</h2><ul><li><strong>Joinpoint(连接点): 那些被拦截到的点，在 Spring 中,这些点指的是方法,因为 Spring 只支持方法类型的连接点</strong></li><li><strong>Pointcut(切入点): 我们要对哪些 Joinpoint 进行拦截的定义</strong></li><li><strong>Advice(通知/增强): 拦截到 Joinpoint 之后所要做的事情就是通知，通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)</strong></li><li>Introduction(引介): 一种特殊的通知，在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或 Field</li><li><strong>Target(目标对象): 代理的目标对象</strong></li><li><strong>Weaving(织入): 把增强(通知)应用到目标对象来创建新的代理对象的过程</strong><ul><li>Spring 采用动态代理织入，而 AspectJ 采用编译期织入和装载类时织入</li></ul></li><li><strong>Proxy（代理）: 一个类被 AOP 织入增强后，就产生一个结果代理类</strong> </li><li><strong>Aspect(切面): 是切入点和通知（引介）的结合</strong></li></ul><p><img src="https://images.csthink.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-19%2016.37.41.png" alt="AOP 相关术语"></p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul><li><strong>Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期生成动态代理对象，通过代理的方式向目标类织入增强代码</strong></li><li><strong>Spring AOP 底层就是通过JDK动态代理或CGLib动态代理技术为目标 Bean 执行横向织入</strong><ul><li>若目标对象实现了若干接口，Spring 默认使用 JDK 的 <code>java.lang.reflect.Proxy</code> 类代理</li><li>若目标对象没有实现任何接口，Spring 使用 CGLib 库生成目标对象的子类</li><li>若目标对象实现了若干接口，也可以通过配置强制使用 CGLIB 实现代理<ul><li>Spring 的配置文件中添加 <code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></li></ul></li></ul></li><li>程序中应优先对接口创建代理，便于程序解耦</li><li>标记为 <code>final</code> 的方法，不能被代理，因为无法进行覆盖<ul><li>JDK 动态代理，是针对接口生成子类，接口中的方法不能使用 final  修饰</li><li>CGLib 是针对目标类生成子类，因此类或方法不能使用 final 修饰</li></ul></li><li>Spring 只支持方法连接点，不提供属性连接</li><li>Spring 的传统 AOP 是基于 <code>ProxyFactoryBean</code>方式的代理</li></ul><h3 id="Spring-AOP-增强类型"><a href="#Spring-AOP-增强类型" class="headerlink" title="Spring AOP 增强类型"></a>Spring AOP 增强类型</h3><ul><li>AOP 联盟为通知 <code>Advice</code> 定义了 <code>org.aopalliance.aop.Interface.Advice</code></li><li>Spring 按照通知<code>Advice</code>在目标类方法的连接点位置，分为5类增强类型<ul><li>前置通知 <code>org.springframework.aop.MethodBeforeAdvice</code>(在目标方法执行前进行增强)</li><li>后置通知 <code>org.springframework.aop.AfterReturningAdvice</code>(在目标方法执行后进行增强)</li><li><strong>环绕通知 <code>org.aopalliance.interceptor.MethodInterceptor</code>(在目标方法执行前后进行增强)</strong></li><li>异常抛出通知 <code>org.springframework.aop.ThrowsAdvice</code>（在方法抛出异常后进行增强）</li><li>引介通知 <code>org.springframework.aop.IntroductionInterceptor</code>(在目标类中添加一些新的方法和属性)</li></ul></li></ul><h3 id="Spring-AOP-切面类型"><a href="#Spring-AOP-切面类型" class="headerlink" title="Spring AOP 切面类型"></a>Spring AOP 切面类型</h3><ul><li><strong>Advisor: 不带有切入点的切面,默认增强类中所有方法</strong>，一般切面，Advice 本身就是一个切面，<strong>对目标类所有方法进行拦截</strong></li><li><strong>PointcutAdvisor: 带有切入点的切面，可以指定拦截目标类的哪些方法</strong></li><li>IntroductionAdvisor: 代表引介切面，针对引介通知而使用的切面</li></ul><h3 id="Spring-传统-AOP-开发-基于-ProxyFactoryBean"><a href="#Spring-传统-AOP-开发-基于-ProxyFactoryBean" class="headerlink" title="Spring 传统 AOP 开发 - 基于 ProxyFactoryBean"></a>Spring 传统 AOP 开发 - 基于 <code>ProxyFactoryBean</code></h3><h4 id="ProxyFactoryBean-常用属性"><a href="#ProxyFactoryBean-常用属性" class="headerlink" title="ProxyFactoryBean 常用属性"></a><code>ProxyFactoryBean</code> 常用属性</h4><ul><li><p>target : 代理的目标对象</p></li><li><p>proxyInterfaces : 代理要实现的接口, 如果多个接口可以使用以下格式赋值</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>proxyTargetClass : 是否对类代理而不是接口，设置为 true 时，使用 CGLib 代理</li><li>interceptorNames : 需要织入目标的Advice</li><li>singleton : 返回代理是否为单实例，默认为单例</li><li>optimize : 当设置为true时，强制使用 CGLib</li></ul><p><strong>AOP 开发所需的 Maven 依赖</strong>   </p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.05.30.png" alt="Maven 依赖"></p><h4 id="不带有切入点的切面开发"><a href="#不带有切入点的切面开发" class="headerlink" title="不带有切入点的切面开发"></a>不带有切入点的切面开发</h4><p>下面是一个不带有切入点的切面开发的Demo，目标类的所有方法都会被增强,不够灵活，实际开发中会采用带有切入点的切面</p><ul><li>Spring 配置文件(SpringDemo1.xml)</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.10.58.png" alt="Spring 配置文件"></p><ul><li>目标类(Service 及其实现类)</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.12.36.png" alt="目标类接口"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.12.55.png" alt="实现类"></p><ul><li><p>后置增强类<br><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.15.08.png" alt="后置增强类"></p></li><li><p>测试类<br><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.15.56.png" alt="测试类"></p></li></ul><p>测试结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加用户...</span><br><span class="line">后置通知 ---&gt; 记录日志...</span><br><span class="line">删除用户...</span><br><span class="line">后置通知 ---&gt; 记录日志...</span><br></pre></td></tr></table></figure><h4 id="带有切入点的切面开发"><a href="#带有切入点的切面开发" class="headerlink" title="带有切入点的切面开发"></a>带有切入点的切面开发</h4><p>下面是一个带有切入点切面开发的Demo，目标类只有指定方法会被增强,<br>这里的目标里没有实现任何接口，Spring 使用 CGLib 的方式创建动态代理</p><ul><li>Spring 配置文件(SpringDemo2.xml)</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.38.20.png" alt="Spring 配置文件"></p><ul><li>目标类(UserDao)</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.39.02.png" alt="目标类"></p><ul><li>环绕增强类</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.39.44.png" alt="环绕增强类"></p><ul><li>测试类</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2014.40.15.png" alt="测试类"></p><p>测试结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环绕前增强 --&gt; 权限校验...</span><br><span class="line">新增操作...</span><br><span class="line">环绕后增强 --&gt; 记录日志...</span><br><span class="line">修改操作...</span><br><span class="line">环绕前增强 --&gt; 权限校验...</span><br><span class="line">删除操作...</span><br><span class="line">环绕后增强 --&gt; 记录日志...</span><br></pre></td></tr></table></figure><h4 id="Spring-传统-AOP-开发-基于-ProxyFactoryBean-小结"><a href="#Spring-传统-AOP-开发-基于-ProxyFactoryBean-小结" class="headerlink" title="Spring 传统 AOP 开发 - 基于 ProxyFactoryBean 小结"></a>Spring 传统 AOP 开发 - 基于 <code>ProxyFactoryBean</code> 小结</h4><ul><li>Spring 会根据目标类是否实现接口采用不同的代理方式<ul><li>实现接口: JDK 动态代理</li><li>没有实现接口: CGLIB 生成代理</li></ul></li><li>基于 <code>ProxyFactoryBean</code> 的方式生成代理配置繁琐，需要为每个需要增强的目标类都配置一个 <code>ProxyFactoryBean</code>，开发维护量巨大，解决方案是下面要谈到的自动创建代理</li><li>使用不带切入点的切面开发进行增强，不够灵活，实际开发中采用带有切入点的切面开发</li></ul><h3 id="Spring-传统-AOP-开发-基于自动代理"><a href="#Spring-传统-AOP-开发-基于自动代理" class="headerlink" title="Spring 传统 AOP 开发 - 基于自动代理"></a>Spring 传统 AOP 开发 - 基于自动代理</h3><h4 id="基于-Bean-名称的自动代理-–-BeanNameAutoProxyCreator"><a href="#基于-Bean-名称的自动代理-–-BeanNameAutoProxyCreator" class="headerlink" title="基于 Bean 名称的自动代理 – BeanNameAutoProxyCreator"></a>基于 Bean 名称的自动代理 – <code>BeanNameAutoProxyCreator</code></h4><p>这个示例中的目标类以及增强通知与前面的例子中都差不多，基于 Bean 名称实现自动代理的这个例子中目标类是两个不实现接口的 Dao，这里仅列出 Spring 的配置文件以及测试类</p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2015.06.33.png" alt="Spring 的配置文件"><br><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2015.07.07.png" alt="测试类"></p><p>测试结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环绕前增强 --&gt; 权限校验...</span><br><span class="line">插入学生记录</span><br><span class="line">环绕后增强 --&gt; 记录日志...</span><br><span class="line">环绕前增强 --&gt; 权限校验...</span><br><span class="line">删除学生记录</span><br><span class="line">环绕后增强 --&gt; 记录日志...</span><br><span class="line">环绕前增强 --&gt; 权限校验...</span><br><span class="line">插入员工记录</span><br><span class="line">环绕后增强 --&gt; 记录日志...</span><br><span class="line">环绕前增强 --&gt; 权限校验...</span><br><span class="line">删除员工记录</span><br><span class="line">环绕后增强 --&gt; 记录日志...</span><br></pre></td></tr></table></figure><h4 id="基于切面信息的自动代理-–-DefaultAdvisorAutoProxyCreator"><a href="#基于切面信息的自动代理-–-DefaultAdvisorAutoProxyCreator" class="headerlink" title="基于切面信息的自动代理 – DefaultAdvisorAutoProxyCreator"></a>基于切面信息的自动代理 – <code>DefaultAdvisorAutoProxyCreator</code></h4><p>这个示例中的目标类以及增强通知与前面的例子中也差不多，目标类是两个实现接口的Dao,增强通知是两个，一是环绕增强，另一个是前置增强，以下是 Spring 的配置文件以及测试类</p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2015.33.16.png" alt="Spring 的配置文件"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-11%20at%2015.35.12.png" alt="测试类"></p><p>测试结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加商品...</span><br><span class="line">环绕前增强....</span><br><span class="line">删除商品...</span><br><span class="line">环绕后增强....</span><br><span class="line">前置增强....</span><br><span class="line">添加分类...</span><br><span class="line">删除分类...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 简介以及 Bean 管理</title>
      <link href="/java/spring_bean.html"/>
      <url>/java/spring_bean.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-框架的优点"><a href="#Spring-框架的优点" class="headerlink" title="Spring 框架的优点"></a>Spring 框架的优点</h2><ul><li>方便解耦，简化开发<ul><li>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系维护，交给 Spring 管理</li></ul></li><li>AOP 编程支持<ul><li>Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截，运行监控等</li></ul></li><li>声明式事务支持<ul><li>只需要通过配置就可以完成对事务的管理</li></ul></li><li>方便程序的测试<ul><li>Spring 对 Junit4 支持，可以通过注解方便的测试程序</li></ul></li><li>方便集成各种优秀框架<ul><li>内部提供了对 Struts、Hibernate、MyBatis 的直接支持</li></ul></li><li>降低 JavaEE API 的使用难度<ul><li>封装了常用的一些 API(JDBC、JavaMail、远程调用等)</li></ul></li></ul><a id="more"></a><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><img src="https://images.csthink.com/spring-overview.png" alt="Spring 模块"></p><ul><li>核心容器包括 <strong><code>spirng-core</code>，<code>spring-beans</code>，<code>spring-context</code>，<code>spring-context-support</code>，<code>spring-expressing</code>(SPEL,Spring表达式语言)</strong></li><li>AOP：AOP 的实现和 AspectJ 的支持</li><li>消息：提供对基于消息应用的支持，提供与 Spring Integration 的集成</li><li>数据访问与集成：JDBC 访问的简化、事务的支持，ORM（Object Relation Mapping）框架（如JPA、Hibernate和 MyBatis等）与 OXM（Object XML Mapping）框架的集成</li><li>Web：Spring MVC 的实现，能集成众多模板引擎技术（如 Thymeleaf、JSP与Velocity等）</li><li>测试：提供大量 Mock 对象，支持单元测试；提供 Spring Context 的测试支持，支持集成测试</li></ul><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p><strong>面向对象编程中，对象之间需要相互通信(一个对象需要访问另一个对象的方法或属性)。比如我们在控制器层需要访问业务层来实现特定的业务功能，业务层又需要访问持久层来完成数据的持久化操作，这里业务层类就是控制器层类的一个依赖类，持久化层也是业务层的一个依赖类，传统的做法是在控制器层自己去使用 new 一个对应的业务层实例来使用。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginService</span>() </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String account, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真正实现登录操作的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LoginService loginService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就是传统的方式，需要的对象由自己去通过 new 去实例化</span></span><br><span class="line">        <span class="keyword">this</span>.loginService = <span class="keyword">new</span> LoginService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用依赖注入(DI)技术，则将依赖类由外部实例化之后注入给控制器层去使用，依赖注入也称为控制反转(IOC)。当创建一个对象时，它所依赖的对象由外部传递给它，而非自己去创建所依赖的对象（比如上面的例子中通过new手动去创建一个 loginService 对象）。因此，也可以说在对象如何获取它的依赖对象这件事情上，控制权反转了。这便是控制反转和依赖注入这两个名字的由来。</strong></p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><strong>面向切面编程（AOP，Aspect Oriented Programming），AOP 用于解耦业务代码和公共服务代码（如日志，安全，事务等），软件开发中经常提一个词，叫做”业务逻辑”或者”业务功能”，我们的代码主要就是实现某种特定的业务逻辑。但是我们往往不能专注于业务逻辑，比如我们写业务逻辑代码的同时，还要关注事务管理、缓存、日志等一系列通用功能，如果每个业务功能都要和这些通用功能混在一起，是一件非常低效和痛苦的事情。所以，为了将业务功能的关注点和通用化功能的关注点分离开来，就需要 AOP 技术了。通用功能的代码实现，对应的就是我们说的切面（Aspect）, 简而言之，AOP 就是一种在开发时将业务相关代码和业务无关的通用功能代码有机分离，而运行时又能够整合到一起形成完整功能的一整套技术</strong></p><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p><strong>任何一个 Java 类都可以是一个 Bean</strong></p><h2 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h2><p><strong>JavaBeans 是一种组件技术，遵循了一些特定的编码约定</strong></p><ul><li>这个类必须具有一个公共的(public)无参构造函数</li><li>所有属性私有化(private)</li><li>私有化的属性必须通过 public 类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范</li><li>这个类应是可序列化的(比如可以实现 Serializable 接口，用于实现 bean 的持久性)</li></ul><p>JavaBean 在 Java EE 开发中，通常用于封装数据，对于遵循以上写法的 JavaBean 组件，其它程序可以通过反射技术实例化 JavaBean 对象，并且通过反射那些遵循命名规范的方法，从而获知 JavaBean 的属性，进而调用其属性保存数据</p><h2 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h2><p><strong>POJO(Plain Old Java Object)指一个简单的普通 Java 对象，不担当任何的特殊的角色，也不实现任何 Java 框架指定的接口，说白了就是一个普通的 Java 类没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的 java 对象，只拥有 private 属性以及对属性访问的 getter 和 setter 方法)，之所以提出 POJO 就是避免与基于重量级开发框架的代码区分开，比如 EJB,使用 EJB 这类框架的 java 代码都被要求按照特定的编码规范，实现特定的接口，继承特定的基类，而 POJO 就是一个普通的 Java 类，没有业务逻辑或持久化逻辑等</strong></p><h2 id="Spring-Beans"><a href="#Spring-Beans" class="headerlink" title="Spring Beans"></a>Spring Beans</h2><p><strong>Spring维护和管理的 POJO，早先 Spring 只能管理符合 JavaBeans 规范的对象，所以称为 Spring Bean,现在只要是 POJO 就能被 Spring 容器管理起来</strong></p><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><ul><li>IOC(Inverse of Control): 就是将原本在程序中手动创建获取一个类的实例的控制权交由 Spring 框架管理，即对象控制权被反转到了 Spring 框架</li><li>依赖注入(DI): 在 Spring 框架创建 Bean 对象时，动态的将依赖对象注入到 Bean 组件</li></ul><h3 id="Spring-IOC-的设计原理"><a href="#Spring-IOC-的设计原理" class="headerlink" title="Spring IOC 的设计原理"></a>Spring IOC 的设计原理</h3><p><img src="https://images.csthink.com/io.png" alt="Spring IOC 的设计原理"></p><h2 id="Spring-工厂类"><a href="#Spring-工厂类" class="headerlink" title="Spring 工厂类"></a>Spring 工厂类</h2><p><img src="https://images.csthink.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-10%2013.58.01.png" alt="Spring 工厂类"></p><ul><li><code>org.springframework.beans</code> 和 <code>org.springframework.context</code>是 Spring IOC 容器的基础</li><li>容器通过读取元数据的配置(Metadata，可以是 XML 的配置文件、注解的配置或 基于 Java 代码中的配置)对 Bean 实现管理(Bean 的实例化、配置以及装配) </li></ul><p><img src="https://images.csthink.com/container-magic.png" alt="Spring 容器"></p><ul><li>Spring 提供了两种不同类型的容器<ul><li><code>org.springframework.context.ApplicationContext</code></li><li><code>org.springframework.beans.factory.BeanFactory</code></li><li><code>ApplicationContext</code> 容器包括了 <code>BeanFactory</code> 容器的所有功能，大部分企业级应用开发中推荐使用</li></ul></li></ul><table><thead><tr><th>Feature</th><th>BeanFactory</th><th>ApplicationContext</th></tr></thead><tbody><tr><td>Bean instantiation/writing</td><td>Yes</td><td>Yes</td></tr><tr><td>Automatic BeanPostProcessor registration</td><td>No</td><td>Yes</td></tr><tr><td>Automatic BeanFactoryPostProcessor registration</td><td>No</td><td>Yes</td></tr><tr><td>Convenient MessageSource access(for i18n)</td><td>No</td><td>Yes</td></tr><tr><td>ApplicationEvent publication</td><td>No</td><td>Yes</td></tr></tbody></table><h3 id="BeanFactory-接口与-ApplicationContext-接口的区别"><a href="#BeanFactory-接口与-ApplicationContext-接口的区别" class="headerlink" title="BeanFactory 接口与 ApplicationContext 接口的区别"></a><code>BeanFactory</code> 接口与 <code>ApplicationContext</code> 接口的区别</h3><ul><li><code>ApplicationContext</code> 接口继承自 <code>BeanFactory</code> 接口，Spring 核心工厂是 <code>BeanFactory</code> , <code>BeanFactory</code> 采取延迟加载，第一次 getBean 时才会初始化 Bean, 而 <code>ApplicationContext</code> 是在加载配置文件时就初始化 Bean</li><li><code>ApplicationContext</code> 是对 <code>BeanFactory</code> 的扩展，它可以进行国际化处理、事件传递和 Bean 自动装配以及各种不同应用层的 Context 实现，开发中基本都在使用 <code>ApplicationContext</code>, web 项目中使用 <code>WebApplicationContext</code>，很少用到 <code>BeanFactory</code></li></ul><h2 id="Spring-的-Bean-管理-XML-方式"><a href="#Spring-的-Bean-管理-XML-方式" class="headerlink" title="Spring 的 Bean 管理 - XML 方式"></a>Spring 的 Bean 管理 - XML 方式</h2><ul><li>需要的依赖有 <code>spring-context</code> ,<code>sprint-core</code>, <code>spring-beans</code>, <code>spring-expression</code><h3 id="XML-文件配置元数据"><a href="#XML-文件配置元数据" class="headerlink" title="XML 文件配置元数据"></a>XML 文件配置元数据</h3></li></ul><p><strong>一般都是在 classpath(即项目的 resources)路径下提供这个配置文件，文件命名无要求，一般是 applicationContext.xml 或 spring.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"https://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"https://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"https://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- bean 标签的 id 属性是一个字符串，被用来标示 Bean，Bean 在被用于依赖类时 id 属性值也表示了当前 Bean 的引用，class 属性定义了 Bean 的类型使用类的全名称(包名.类名)  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bean 标签的 id 和 name 属性功能基本相同，除了 name 可以使用特殊字符命名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-配置-Bean-实例化的方式"><a href="#Spring-配置-Bean-实例化的方式" class="headerlink" title="Spring 配置 Bean 实例化的方式"></a>Spring 配置 Bean 实例化的方式</h3><p><strong>设置 Spring 如何来实例化 Bean 类</strong></p><ul><li>通过无参构造器实例化，类中提供了无参的构造器</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"anotherExample"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBeanTwo"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过静态工厂实例化</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span> <span class="attr">class</span>=<span class="string">"examples.ClientService"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实例工厂实例化</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建工厂实例 serviceLocator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过工厂实例创建目标 Bean 实例，factory-bean 指工厂实例，factory-method 指的是创建目标 Bean 的方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span> <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span> <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 工厂实例同时拥有创建另一个目标 Bean 实例的能力 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span> <span class="attr">factory-method</span>=<span class="string">"createAccountServiceInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultServiceLocator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 给内部类实例时，class 属性应该这样定义 <code>com.xxx.OuterClass$InnerClass</code></p><h3 id="Spring-的生命周期"><a href="#Spring-的生命周期" class="headerlink" title="Spring 的生命周期"></a>Spring 的生命周期</h3><p><strong>Spring 初始化 Bean 或销毁 Bean 时，调用 Bean 的两个生命周期方法, init-method 指定 Bean 的初始化方法,destroy-method 指定 Bean 的销毁方法</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法名不限定必须是 init 或 destroy --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- destroy-method 只对 scope="singleton" 有效  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 销毁方法，必须关闭 ApplicationContext 对象(手动调用)，才会被调用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- XML 文件头部声明中可以添加全局默认的初始化和销毁方法 default-init-method="init" default-destroy-method="destroy" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>手动关闭 ApplicationContext的方式<br><img src="https://images.csthink.com/Carbonize%202019-04-10%20at%2021.36.17.png" alt="手动关闭 ApplicationContext的方式"></p><h4 id="Spring-Bean-的完整生命周期"><a href="#Spring-Bean-的完整生命周期" class="headerlink" title="Spring Bean 的完整生命周期"></a>Spring Bean 的完整生命周期</h4><blockquote><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 Bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期</p></blockquote><ol><li>instantiate bean 对象实例化</li><li>populate properties 封装属性</li><li>如果 Bean 实现 <code>BeanNameAware</code> 执行 <code>setBeanName</code></li><li>如果 Bean 实现 <code>BeanFactoryAware</code> 或者 <code>ApplicationContextAware</code> 设置工厂 <code>setBeanFactory</code> 或者上下文对象 <code>setApplicationContext</code></li><li>如果存在类实现 <code>BeanPostProcessor</code>，执行<code>postProcessBeforeInitialization</code>，<code>BeanPostProcessor</code> 接口提供钩子函数，用来动态扩展修改 Bean</li><li>如果 Bean 实现 <code>InitializingBean</code> 执行 <code>afterPropertiesSet</code></li><li>调用 <code>&lt;bean init-method=&quot;init&quot;&gt;</code> 指定自定义的初始化方法 <code>init</code></li><li>如果存在类实现 <code>BeanPostProcessor</code> ，执行<code>postProcessAfterInitialization</code></li><li>Bean 准备就绪，可以执行自定义业务处理</li><li>如果 Bean 实现 <code>DisposableBean</code> 执行 <code>destroy</code></li><li>调用 <code>&lt;bean destroy-method=&quot;customerDestroy&quot;&gt;</code> 自定义的销毁方法 <code>customerDestroy</code></li></ol><ul><li>第三步和第四步: 主要让生成的 Bean 了解 Spring 容器.</li><li>第五步和第八步: 允许客户在 Bean 的生成过程中对 Bean 的实例进行增强</li><li><code>BeanPostProcessor</code>: 工厂勾子.允许客户在生成类的过程中对类进行增强</li></ul><h4 id="Spring-Bean-的作用域"><a href="#Spring-Bean-的作用域" class="headerlink" title="Spring Bean 的作用域"></a>Spring Bean 的作用域</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Bean标签属性 scope 限制作用范围 默认:singleton --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>在 Spring IOC 容器中仅存在一个 Bean 实例，默认就是这个作用范围</td></tr><tr><td>prototype</td><td>每次调用 getBean() 时都会返回一个新的实例</td></tr><tr><td>request</td><td>每次 HTTP 请求都会创建一个新的 Bean,该作用域仅适用于 WebApplicationContext 环境</td></tr><tr><td>session</td><td>同一个 HTTP Session 共享一个 Bean,不同的 Session 使用不同的 Bean,该作用域仅适用于 WebApplicationContext 环境</td></tr><tr><td>global session</td><td>在一个全局的HTTP Session 中，一个 Bean 定义对应一个实例，该作用域仅适用于 WebApplicationContext 环境</td></tr><tr><td>application</td><td>ServletContext 生命周期共享一个 Bean,该作用域仅适用于 WebApplicationContext 环境</td></tr></tbody></table><h3 id="Spring-Bean-的属性-id-与-name"><a href="#Spring-Bean-的属性-id-与-name" class="headerlink" title="Spring Bean 的属性 id 与 name"></a>Spring Bean 的属性 id 与 name</h3><ul><li>用于标示 Bean 的名称，唯一性,小驼峰方式命名 </li><li>id 属性或 name 属性都可以用来给 Bean 命名，若 Bean 名称包含有特殊字符，只能使用 name 属性</li><li>可以使用 alias 元素给 Bean 起别名</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"myBean"</span> <span class="attr">alias</span>=<span class="string">"myAliaBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Bean-的属性注入"><a href="#Spring-Bean-的属性注入" class="headerlink" title="Spring Bean 的属性注入"></a>Spring Bean 的属性注入</h3><ul><li>构造器注入(通过 <code>&lt;constructor-arg&gt;</code> 元素完成注入)</li><li>set 注入(通过<property> 元素完成注入)<ul><li>普通 setter 的注入</li><li>使用 p 名称空间实现 setter 方式简化属性注入(Spring 2.5)</li><li>使用 c 名称空间实现 setter 方式的属性注入</li><li>SpEL 方式实现属性注入(Spring 3.0)</li><li>复杂类型的属性注入</li></ul></property></li></ul><h4 id="Bean-的属性注入-构造器注入"><a href="#Bean-的属性注入-构造器注入" class="headerlink" title="Bean 的属性注入: 构造器注入"></a><strong>Bean 的属性注入: 构造器注入</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean-的属性注入-普通-setter-注入-类中必须有对应属性的-setter-方法"><a href="#Bean-的属性注入-普通-setter-注入-类中必须有对应属性的-setter-方法" class="headerlink" title="Bean 的属性注入: 普通 setter 注入,类中必须有对应属性的 setter 方法"></a><strong>Bean 的属性注入: 普通 setter 注入,类中必须有对应属性的 setter 方法</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Cat"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"kitty"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean-的属性注入-使用-p-名称空间实现-setter-方式的属性注入-可简化-xml-配置，类中必须有对应属性的-setter-方法-ref-表示其他-Bean-类的引用"><a href="#Bean-的属性注入-使用-p-名称空间实现-setter-方式的属性注入-可简化-xml-配置，类中必须有对应属性的-setter-方法-ref-表示其他-Bean-类的引用" class="headerlink" title="Bean 的属性注入: 使用 p 名称空间实现 setter 方式的属性注入, 可简化 xml 配置，类中必须有对应属性的 setter 方法, -ref 表示其他 Bean 类的引用"></a><strong>Bean 的属性注入: 使用 p 名称空间实现 setter 方式的属性注入, 可简化 xml 配置，类中必须有对应属性的 setter 方法, <code>-ref</code> 表示其他 Bean 类的引用</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用前提: applicationContext.xml 配置文件头声明添加 xmlns:p="https://www.springframework.org/schema/p"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Cat"</span> <span class="attr">p:name</span>=<span class="string">"小花"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Cat"</span> <span class="attr">p:species-ref</span>=<span class="string">"波斯猫"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Bean-的属性注入-使用-c-名称空间实现-setter-方式的属性注入-可简化-xm-l配置，类中必须有对应属性的-setter-方法-ref-表示其他-Bean-类的引用"><a href="#Bean-的属性注入-使用-c-名称空间实现-setter-方式的属性注入-可简化-xm-l配置，类中必须有对应属性的-setter-方法-ref-表示其他-Bean-类的引用" class="headerlink" title="Bean 的属性注入: 使用 c 名称空间实现 setter 方式的属性注入, 可简化 xm l配置，类中必须有对应属性的 setter 方法, -ref 表示其他 Bean 类的引用"></a><strong>Bean 的属性注入: 使用 c 名称空间实现 setter 方式的属性注入, 可简化 xm l配置，类中必须有对应属性的 setter 方法, <code>-ref</code> 表示其他 Bean 类的引用</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用前提: applicationContext.xml 配置文件头声明添加 xmlns:c="https://www.springframework.org/schema/c"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Cat"</span> <span class="attr">c:name</span>=<span class="string">"小花"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Cat"</span> <span class="attr">c:species-ref</span>=<span class="string">"波斯猫"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Bean-的属性注入-SpEL-方式实现属性注入"><a href="#Bean-的属性注入-SpEL-方式实现属性注入" class="headerlink" title="Bean 的属性注入: SpEL 方式实现属性注入"></a><strong>Bean 的属性注入: SpEL 方式实现属性注入</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"productInfo"</span> <span class="attr">class</span>=<span class="string">"com.xxx.ProductInfo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"category"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Category"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;'服装'&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"product"</span> <span class="attr">class</span>=<span class="string">"com.xxx.Product"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;'上衣'&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"#&#123;productInfo.calculatePrice(199.00)&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"category"</span> <span class="attr">value</span>=<span class="string">"#&#123;category&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Bean-的属性注入-复杂类型的属性注入"><a href="#Bean-的属性注入-复杂类型的属性注入" class="headerlink" title="Bean 的属性注入: 复杂类型的属性注入"></a><strong>Bean 的属性注入: 复杂类型的属性注入</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数组类型的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arr"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>...<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>...<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- List 类型的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>...<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>...<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Set 类型的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>...<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>...<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map 类型的属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key1"</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key2"</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Properties 类型的属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"..."</span>&gt;</span>...<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getArr() &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArr</span><span class="params">(String[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSet</span><span class="params">(Set&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-容器的实例化"><a href="#Spring-容器的实例化" class="headerlink" title="Spring 容器的实例化"></a>Spring 容器的实例化</h3><p>这是一个 <code>services.xml</code>, service 层包含了一个 <code>PetStoreServiceImpl</code> 实现类，和两个 Dao 层对象</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"https://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"https://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"https://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"itemDao"</span> <span class="attr">ref</span>=<span class="string">"itemDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个 <code>daos.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"https://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"https://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"https://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 容器实例化方法</p><p><img src="https://images.csthink.com/Carbonize%202019-04-10%20at%2014.45.28.png" alt="Spring 容器实例化方法"></p><p><strong>配置文件中引入其他配置文件 <code>&lt;import resource=&quot;applicationContext2.xml&quot;&gt;</code></strong></p><h3 id="使用-Spring-容器获取-Bean-实例"><a href="#使用-Spring-容器获取-Bean-实例" class="headerlink" title="使用 Spring 容器获取 Bean 实例"></a>使用 Spring 容器获取 Bean 实例</h3><p>使用 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> 方法可以获取 Bean 实例</p><p><img src="https://images.csthink.com/Carbonize%202019-04-10%20at%2014.51.48.png" alt="Spring 容器获取 Bean 实例"></p><h2 id="Spring-的-Bean-管理-Annotation-注解方式"><a href="#Spring-的-Bean-管理-Annotation-注解方式" class="headerlink" title="Spring 的 Bean 管理 - Annotation(注解方式)"></a>Spring 的 Bean 管理 - Annotation(注解方式)</h2><ul><li>需要 <code>spring-aop</code> 的依赖</li><li>使用注解的方式必须在Spring 的配置文件中，引入 context 的约束,并开启注解扫描</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"https://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"https://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"https://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"https://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描, 假如com.csthink 有多个子包，这样声明后就可以在所有的包中都开启注解扫描  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.csthink"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注解定义-Bean"><a href="#注解定义-Bean" class="headerlink" title="注解定义 Bean"></a>注解定义 Bean</h3><ul><li><strong><code>@Component(value=&quot;xxxx&quot;)</code> Spring 框架中的普通类注解，以下是一些衍生注解，根据类的角色划分,为了让标注类本身的用途清晰</strong><ul><li><code>@Controller(value=&quot;xxx&quot;)</code> 用于对 Controller 类进行标注</li><li><code>@Service(value=&quot;xxx&quot;)</code> 用于对 Service 类进行标注</li><li><code>@Repository(value=&quot;xxx&quot;)</code> 用于对 DAO 类进行标注</li></ul></li></ul><h3 id="注解方式实现属性注入"><a href="#注解方式实现属性注入" class="headerlink" title="注解方式实现属性注入"></a>注解方式实现属性注入</h3><ul><li><p><strong><code>@Value</code> 注入普通类型的属性，若属性存在 setter 方法，应放在 setter 方法上面修饰</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(value=<span class="string">"jack"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li><li><p><code>@Autowired</code></p><ul><li>默认按类型完成属性的注入，若存在两个相同的 Bean，类型相同，则按照名称注入，可以针对成员变量或 set 方法</li><li>required 属性，设置一定要找到匹配的 Bean</li><li>使用名称的方式来完成属性的注入 <code>@Qulifier(value=&quot;xxx&quot;)</code>,注解 Bean 必须指定相同的名称</li></ul></li><li><p><code>@Resource</code></p><ul><li><code>@Resource(name=&quot;xxx&quot;)</code> 相当于 <code>@Autowired</code> 与 <code>@Qulifier(value=&quot;xxx&quot;)</code> 一起使用完成按名称的属性注入</li><li>Spring 提供对 JSR-250中定义 <code>@Resource</code> 标准注解的支持</li></ul></li><li><p><code>@PostConstruct</code></p><ul><li>相当于 init-method， 注意 destroy-method 使用的前提是 Bean 是在单例模式，即 scope 为 singleton</li></ul></li><li><p><code>@PreDestroy</code></p><ul><li>相当于 destroy-method</li></ul></li></ul><h3 id="注解方式修改类的作用范围"><a href="#注解方式修改类的作用范围" class="headerlink" title="注解方式修改类的作用范围"></a>注解方式修改类的作用范围</h3><ul><li><p><code>@Scope</code></p><ul><li><p>相当于 scope 属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"xxx"</span>)</span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="XML-配置与-注解的对比"><a href="#XML-配置与-注解的对比" class="headerlink" title="XML 配置与 注解的对比"></a>XML 配置与 注解的对比</h3><ul><li>XML 方式，结构清晰，易于阅读</li><li>注解方式，开发便捷，属性注入方便</li></ul><h2 id="XML和注解的整合开发，XML-用于管理-Bean-注解用于属性的注入"><a href="#XML和注解的整合开发，XML-用于管理-Bean-注解用于属性的注入" class="headerlink" title="XML和注解的整合开发，XML 用于管理 Bean,注解用于属性的注入"></a>XML和注解的整合开发，XML 用于管理 Bean,注解用于属性的注入</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只开启属性注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的管理使用 XML 中配置 &lt;bean id="userService" class=""&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Userservice</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只使用属性注入</span></span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userdao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的管理使用 XML 中配置 &lt;bean id="userDao" class=""&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-的-Bean-管理-JavaConfig-方式"><a href="#Spring-的-Bean-管理-JavaConfig-方式" class="headerlink" title="Spring 的 Bean 管理 - JavaConfig 方式"></a>Spring 的 Bean 管理 - JavaConfig 方式</h2><p>使用Java类作为配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"person"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        p.setName(<span class="string">"jack"</span>);</span><br><span class="line"></span><br><span class="line">        p.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"student"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">showStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Student stud = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        stud.setName(<span class="string">"rose"</span>);</span><br><span class="line"></span><br><span class="line">        stud.setScore(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stud;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet 与 JSP</title>
      <link href="/java/servlet.html"/>
      <url>/java/servlet.html</url>
      
        <content type="html"><![CDATA[<h2 id="CGI、fast-cgi、servlet-区别"><a href="#CGI、fast-cgi、servlet-区别" class="headerlink" title="CGI、fast-cgi、servlet 区别"></a>CGI、fast-cgi、servlet 区别</h2><blockquote><p>Sun Microsystems 公司在1996年发布 Servlet 技术就是为了和 CGI 进行竞争，Servlet 是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个Servlet 类。Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递给 Servlet 程序，并将 Servlet 的响应回传给用户。通常一个Servlet 会关联一个或多个 JSP 页面。以前CGI经常因为性能开销上的问题被诟病，不过 Fast CGI经解决了 CGI 效率上的问题</p></blockquote><a id="more"></a><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><ul><li>Web服务器每收到一个请求，都会去 fork 一个 cgi 进程，请求结束再 kill 掉这个进程。这样假如有10000个请求，就需要 fork、kill cgi 进程10000次，带来很大的开销</li></ul><h3 id="fast-cgi"><a href="#fast-cgi" class="headerlink" title="fast-cgi"></a>fast-cgi</h3><ul><li>fast-cgi 每次处理完请求后，不会 kill 掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新 fork 一个进程了，大大提高了效率</li><li>比如 php-fpm 是 FastCGI 的实现，并提供了进程管理的功能,进程包含 master 进程和 worker 进程两种进程。master 进程只有一个，负责监听端口，接收来自 Web服务器的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方</li></ul><h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><ul><li>只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</li><li>如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</li><li>所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量</li><li>Servlet 能直接和 Web服务器交互，而普通的 CGI 程序不能</li><li>Servlet 还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现    </li></ul><h2 id="Cookie-与-Session"><a href="#Cookie-与-Session" class="headerlink" title="Cookie 与 Session"></a>Cookie 与 Session</h2><p><strong>背景: HTTP 是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是 Session</strong></p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><strong>由服务器发给客户端的特殊信息，以文本的形式存放在客户端</strong></p><ol><li><p>当用户使用浏览器访问一个支持 Cookie 的网站时，用户会提供包括用户名在内的个人信息提交至服务器</p></li><li><p>服务器向客户端响应相应的资源，也会将用户的个人信息回传给客户端，这些个人信息不会存放在 HTTP 响应体及 Response Body 中，而是存放在 HTTP 响应头以及 Response Header 中</p></li><li><p>客户端接收到来自服务端的响应后，浏览器会将这些信息存放在一个统一的位置</p></li><li><p>客户端再次请求服务器时，会把 Cookie 携带上发给服务器，这时 Cookie 存放在 Http 的请求头中</p></li><li><p>服务器接收到 Cookie 后，会解析 Cookie，生成与客户端相对应的内容</p><p> <strong>网站登陆”记住我”的功能就是基于Cookie的实现</strong></p></li></ol><h3 id="Cookie-的设置以及发送过程"><a href="#Cookie-的设置以及发送过程" class="headerlink" title="Cookie 的设置以及发送过程"></a>Cookie 的设置以及发送过程</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Web Client                        Web Server</span><br><span class="line">1. ===== HTTP Request =================&gt;</span><br><span class="line">2. &lt;==== HTTP Response + Set-Cookie =====</span><br><span class="line">3. ===== HTTP Request + Cookie =========&gt;</span><br><span class="line">4. &lt;==== HTTP Response ==================</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><strong>服务器端的机制，在服务器上保存的信息,解析客户端请求并操作 session id ,按需保存状态信息， session id 会被发送给客户端</strong></p><h3 id="Session-的实现方式"><a href="#Session-的实现方式" class="headerlink" title="Session 的实现方式"></a><strong>Session 的实现方式</strong></h3><h4 id="方式一-使用-Cookie-来实现"><a href="#方式一-使用-Cookie-来实现" class="headerlink" title="方式一: 使用 Cookie 来实现"></a>方式一: 使用 Cookie 来实现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Web Client                    Web Server</span><br><span class="line">        ----------- Request ----------&gt;</span><br><span class="line">        &lt;-------- Response ----------</span><br><span class="line">        Set-Cookie：JSESSIONID=xxx</span><br><span class="line">        --------- Request -----------&gt;</span><br><span class="line">        Cookie:JSESSIONID=xxxx</span><br><span class="line">        &lt;--------- Response ----------</span><br></pre></td></tr></table></figure><h4 id="方式二-使用-URL回写来实现"><a href="#方式二-使用-URL回写来实现" class="headerlink" title="方式二: 使用 URL回写来实现"></a>方式二: 使用 URL回写来实现</h4><ul><li>服务器发送给浏览器的所有页面中的链接中，都携带 JSESSIONID 的参数，这样浏览器发送请求时就会携带上 JSESSIONID 带回服务器</li><li>Tomcat 同时支持 Cookie 和 URL 回写两种方式实现 Session，默认使用 Cookie</li></ul><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别?"></a>Cookie 和 Session 的区别?</h3><ol><li>Cookie 存放在客户端浏览器，Session 存在服务器上</li><li>Session 相对 Cookie 更安全</li><li>若考虑减轻服务器负担，应使用 Cookie，Session 占用服务器空间</li></ol><h2 id="get-与-post-请求的区别"><a href="#get-与-post-请求的区别" class="headerlink" title="get 与 post 请求的区别"></a>get 与 post 请求的区别</h2><ul><li>HTTP 报文层面: <ul><li>GET 将请求信息放在 URL(键值对)，POST 放在报文体中,需要解析，都是明文传输，安全性无太大差别，安全需要靠 HTTPS</li><li>某些浏览器如 FF 等对 GET 请求的 URL 长度有限制(2048个字符)，POST 因为数据在报文体中，所以无限制</li></ul></li><li>数据库层面:<ul><li>GET 符合幂等性和安全性，POST不符合(有副作用)<ul><li>幂等性: 对数据库的一次操作与多次操作，获得的结果是一致的</li><li>安全性: 指的是没有改变数据库中的数据</li></ul></li></ul></li><li>其他层面:<ul><li>GET 可以被缓存，被存储，而 POST 不行</li></ul></li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p><strong>在 Java Web 程序中，Servlet 主要负责接收用户请求 HttpServletRequest,在 doGet(),doPost() 中做相应的处理，并通过 HttpServletResponse 响应给用户</strong></p><ul><li>Java Servlet 的简称，称为小服务程序或服务连接器</li><li>用 Java 编写的服务器端程序</li><li>主要功能在与交互式地浏览和修改数据，生成动态的 web 内容</li></ul><h3 id="Servlet-的使用"><a href="#Servlet-的使用" class="headerlink" title="Servlet 的使用"></a>Servlet 的使用</h3><ul><li>可以设置初始化参数，供 Servlet内部使用</li><li>一个 Servlet 类只会有一个实例，在它初始化时调用 init() 方法，销毁时调用 destroy() 方法</li><li>Servlet 需要在 web.xml 中配置，或使用注解配置 URL，一个 Servlet 可以设置多个 URL 访问</li><li>Servlet 不是线程安全，因此要谨慎使用类变量</li></ul><h3 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h3><p><strong>init 方法和 destroy 方法只会执行一次，service 方法客户端每次请求Servlet 都会执行</strong></p><ol><li>Web容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其init() 方法进行 Servlet 的初始化<ul><li>初始化资源的代码放入init方法中 </li></ul></li><li>响应客户请求阶段调用 service()方法，根据请求类型去调用 doGet() 或 doPost()</li><li>当服务器关闭或项目被卸载时服务器会将 Servlet 实例销毁，此阶段调用 destroy()方法<ul><li>销毁资源的代码放入 destroy 方法中</li></ul></li></ol><h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><ul><li>浏览器对服务器的一次访问称为一次请求，请求用 HttpServletRequest 对象表示</li><li>服务器给浏览器的一次反馈称为一次响应，响应用 HttpServletResponse 对象表示</li></ul><h3 id="ServletContext-与-ServletConfig"><a href="#ServletContext-与-ServletConfig" class="headerlink" title="ServletContext 与 ServletConfig"></a>ServletContext 与 ServletConfig</h3><ul><li>整个 JavaWeb 工程用一个对象来表示就是 ServletContext</li><li>web.xml 中给某一个 Servlet 配置一些信息，当服务器启动的时候，这些配置就会被加载到某一个 ServletConfig 对象中，所以 ServletConfig 表示的就是某一个 Servlet 的配置文件</li></ul><h3 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><ol><li>实现方式<ul><li><strong>转发的实现方式是 HttpServletRequest 对象中的方法</strong><ul><li><code>request.getRequestDispatcher(&quot;xxx&quot;).forward(request, response);</code></li></ul></li><li><strong>重定向的实现方式是 HttpServletResponse 对象中的方法</strong><ul><li><code>response.sendRedirect(&quot;xxxx&quot;);</code></li></ul></li></ul></li><li>地址栏显示<ul><li><strong>转发时浏览器 URL 不改变</strong><ul><li>转发是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址</li></ul></li><li><strong>重定向时浏览器 URL 会改变</strong><ul><li>重定向是服务端根据逻辑,服务端发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的 URL</li></ul></li></ul></li><li>数据共享<ul><li><strong>转发页面和转发到的页面可以共享request里面的数据</strong></li><li><strong>重定向不能共享数据</strong></li></ul></li><li>效率<ul><li>转发效率高于重定向</li></ul></li></ol><h3 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a>自动刷新</h3><p><strong>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response.setHeader(<span class="string">"Refresh"</span>,<span class="string">"5;URL=https://localhost:8080/servlet/example.htm"</span>); <span class="comment">// 5 是指时间5秒，URL就是要跳转的页面，若设置为自己的路径，实现的就是5秒自动刷新本页面一次</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=&lt;%=request.getContextPath() %&gt;/forum/list.do"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p><strong>Java Server Pages，一个简化的 Servlet 设计。在 HTML 文件中插入 Java 程序和 JSP 标记（tag）,形成后缀名为(.jsp)的文件，跨平台，JSP 会被服务器处理成一个类似于Servlet 的 Java 程序，可以简化页面内容的生成</strong></p><h3 id="JSP-与-Servlet-的区别"><a href="#JSP-与-Servlet-的区别" class="headerlink" title="JSP 与 Servlet 的区别"></a>JSP 与 Servlet 的区别</h3><ol><li>JSP 本质上是简化的 Servlet,由 HTML 代码和 JSP 标签构成</li><li>Servlet 是由 Java 程序代码构成的，</li><li>Servlet 的应用逻辑是在 Java 文件中，且从表示层中的 HTML 里分离处理，MVC 架构模式中,JSP 侧重于视图，Servlet 适合用于控制逻辑</li></ol><h3 id="JSP-工作原理"><a href="#JSP-工作原理" class="headerlink" title="JSP 工作原理"></a>JSP 工作原理</h3><p><strong>HttpServlet 是先由源代码编译为 class 文件后部署到服务器下，为先编译后部署,而 JSP 则是先部署后编译</strong></p><ul><li>客户端第一次请求 JSP 文件时,JSP 会被编译为 HttpJspPage 类<ul><li>Servlet 类的一个子类，该类会被服务器临时存放在服务器工作目录里面</li></ul></li><li>JSP 被编译成的 .class 文件就是JSP对应的 Servlet，编译完毕后运行 class 文件来响应客户端的请求，以后再次请求的时候，Tomcat 将不再重新编译 JSP 文件，而是直接调用 class 文件来响应客户端的请求<ul><li>客户端第一次请求的时候 JSP 文件会被编译，所以第一次请求 JSP 时感觉比较慢，之后会感觉快很多，若将服务器上的 class文件删除，服务器也会重新编译 JSP</li></ul></li></ul><p>开发Web程序时经常需要修改 JSP。Tomcat 能够自动检测到 JSP 程序的改动。如果检测到J SP 源代码发生了改动。Tomcat 会在下次客户端请求 JSP 时重新编译 JSP，而不需要重启 Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署 Web 应用的时候可以在 web.xml 中将它关掉</p><h3 id="JSP-语法"><a href="#JSP-语法" class="headerlink" title="JSP 语法"></a>JSP 语法</h3><h3 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h3><ul><li>定义成员变量，以及成员方法</li><li>不能直接包含程序语句</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2019.37.13.png" alt="JSP 声明语法"></p><h3 id="程序脚本"><a href="#程序脚本" class="headerlink" title="程序脚本"></a>程序脚本</h3><ul><li>包括变量的声明、表达式和程序逻辑</li><li>声明的变量转换为 service 方法中的变量，因此是局部变量</li><li>语句块可以自由地将 Java 脚本与页面代码组合使用</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2019.45.00.png" alt="程序脚本"></p><h3 id="JSP-注释"><a href="#JSP-注释" class="headerlink" title="JSP 注释"></a>JSP 注释</h3><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2019.47.47.png" alt="JSP 注释"></p><h3 id="JSP-内容输出表达式"><a href="#JSP-内容输出表达式" class="headerlink" title="JSP 内容输出表达式"></a>JSP 内容输出表达式</h3><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2019.51.45.png" alt="JSP 内容输出表达式"></p><h3 id="JSP-包引入语法"><a href="#JSP-包引入语法" class="headerlink" title="JSP 包引入语法"></a>JSP 包引入语法</h3><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2019.54.12.png" alt="JSP 包引入语法"></p><h3 id="JSP-内置对象"><a href="#JSP-内置对象" class="headerlink" title="JSP 内置对象"></a>JSP 内置对象</h3><p><strong>内置对象(隐含对象，9个内置对象),不需要预先声明就可以在脚本代码和表达式中随意使用</strong></p><ol><li>request: 封装客户端的请求，其中包含来自 GET 或 POST 请求的参数，作用域是用户的请求周期</li><li>response: 封装服务器对客户端的响应</li><li>session: 封装用户会话的对象</li><li>out: 输出服务器响应的输出流对象</li><li>application: 封装服务器运行环境的对象(服务器版本，应用级初始化参数和应用内资源绝对路径，注册信息的方式)，作用域是 web 容器的生命周期</li><li>page: 正在运行的由 JSP 文件产生的类对象，JSP 页面本身（相当于 Java 程序中的 this）</li><li>pageContext: 通过该对象可以获取其他对象</li><li>exception: 封装页面抛出异常的对象</li><li>config: Web 应用的配置对象</li></ol><h4 id="JSP-中的四大作用域"><a href="#JSP-中的四大作用域" class="headerlink" title="JSP 中的四大作用域"></a>JSP 中的四大作用域</h4><p><strong>JSP 中的四种作用域包括 page、request、session 和 application</strong></p><ul><li>page 代表与一个页面相关的对象和属性</li><li>request 代表 Web 客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域</li><li>session 代表某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中</li><li>application 代表整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域</li></ul><h4 id="JSP-三大指令"><a href="#JSP-三大指令" class="headerlink" title="JSP 三大指令"></a>JSP 三大指令</h4><h5 id="page-指令"><a href="#page-指令" class="headerlink" title="page 指令"></a>page 指令</h5><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2021.56.08.png" alt="page 指令"></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>buffer</td><td>指定 out 对象使用缓冲区大小</td></tr><tr><td>autoFlush</td><td>控制 out 对象的缓冲区</td></tr><tr><td>contentType</td><td>指定当前 JSP 页面的 MIME 类型和字符编号</td></tr><tr><td>errorPage</td><td>指定当前 JSP 页面发生异常时需要转向的错误处理页面</td></tr><tr><td>isErrorPage</td><td>指定当前页面是否可以作为另一个JSP页面的错误处理页面</td></tr><tr><td>extends</td><td>指定 servlet 从哪一个类继承</td></tr><tr><td>import</td><td>导入需要使用的类</td></tr><tr><td>info</td><td>定义 JSP 页面的描述信息</td></tr><tr><td>language</td><td>指定对 JSP 页面所用的脚本语言，默认是 java</td></tr><tr><td>isThreadSafe</td><td>指定对 JSP页面的访问是否是线程安全</td></tr><tr><td>session</td><td>指定 JSP 页面是否使用 session</td></tr><tr><td>isELIgnored</td><td>指定是否执行 EL 表达式</td></tr><tr><td>isScriptEnable</td><td>确定脚本元素能否被使用</td></tr></tbody></table><h5 id="include-指令"><a href="#include-指令" class="headerlink" title="include 指令"></a>include 指令</h5><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2021.39.24.png" alt="include 指令与 include 行为"></p><h6 id="include-指令与-include-行为的区别"><a href="#include-指令与-include-行为的区别" class="headerlink" title="include 指令与 include 行为的区别"></a>include 指令与 include 行为的区别</h6><ul><li><p>include 指令: JSP 可以通过 include 指令来包含其他文件。被包含的文件可以是 JSP 文件、HTML 文件或文本文件。包含的文件就好像是该 JSP 文件的一部分，会被同时编译执行。 语法格式如下： <code>&lt;%@ include file=&quot;文件相对 url 地址&quot; %&gt;</code></p></li><li><p>include 行为： jsp:include 行为元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下： <code>&lt;jsp:include page=&quot;相对 URL 地址&quot; flush=&quot;true&quot; /&gt;</code></p></li></ul><h5 id="taglib-指令"><a href="#taglib-指令" class="headerlink" title="taglib 指令"></a>taglib 指令</h5><p><strong>taglib 指令是用来在当前 jsp 页面中导入第三方的标签库</strong></p><ul><li>prefix：指定标签前缀，这个东西可以随意起名 </li><li>uri：指定第三方标签库的uri（唯一标识）<br>当然，需要先把第三方标签库所需jar包放到类路径中</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2021.41.27.png" alt="taglib 指令"></p><h4 id="JSP-七大动作"><a href="#JSP-七大动作" class="headerlink" title="JSP 七大动作"></a>JSP 七大动作</h4><ul><li>jsp:include：在页面被请求的时候引入一个文件 </li><li>jsp:useBean：寻找或者实例化一个 JavaBean</li><li>jsp:setProperty：设置 JavaBean 的属性</li><li>jsp:getProperty：输出某个 JavaBean 的属性 </li><li>jsp:forward：把请求转到一个新的页面</li><li>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记</li></ul><h3 id="附录-内置对象常用方法"><a href="#附录-内置对象常用方法" class="headerlink" title="附录: 内置对象常用方法"></a>附录: 内置对象常用方法</h3><h4 id="request-请求对象常用方法"><a href="#request-请求对象常用方法" class="headerlink" title="request 请求对象常用方法"></a>request 请求对象常用方法</h4><p><strong>隐藏对象 request 是 javax.servlet.ServletRequest 类的实例，代表客户端的请求。request 包含客户端的信息以及请求的信息，如请求哪个文件，附带的地址参数等。每次客户端的请求都会产生一个 request 实例</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object getAttribute(String name)</td><td>返回由 name 指定属性的属性值</td></tr><tr><td>Enumeration getAttributeNames()</td><td>返回 request 对象所有属性的名字集合，结果是一个枚举的实例</td></tr><tr><td>String getCharacterEncoding()</td><td>返回请求中的字符编码方式</td></tr><tr><td>int getContextLength()</td><td>返回请求体 Body 的长度</td></tr><tr><td>String getContentType()</td><td>得到请求体的 MIME 类型</td></tr><tr><td>ServletInputStream getInputStream()</td><td>返回请求的输入流，用于获得请求中的数据</td></tr><tr><td>String getParameter(String name)</td><td>获得客户端传送给服务器端的有 name指定的参数值</td></tr><tr><td>Enumeration getParameterNames()</td><td>获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</td></tr><tr><td>String[] getparameterValues(String name)</td><td>获得有 name 指定的参数的所有值</td></tr><tr><td>String getProtocol()</td><td>获取客户端向服务器端传送数据所依据的协议名称</td></tr><tr><td>String getScheme()</td><td>返回请求用的计划名,如:http https及ftp等</td></tr><tr><td>int getServerPort()</td><td>返回服务器端口号</td></tr><tr><td>String getServerName()</td><td>返回服务器主机名</td></tr><tr><td>BufferedReader getReader()</td><td>返回解码过了的请求体</td></tr><tr><td>String getRemoteAddr()</td><td>返回客户端IP地址</td></tr><tr><td>String getRemoteHost()</td><td>返回客户端主机名</td></tr><tr><td>void setAttribute(String name, Object obj)</td><td>设置名字为 name 的request 属性值</td></tr><tr><td>String getRealPath(String path)</td><td>返回一虚拟路径的真实路径</td></tr><tr><td>String getQueryString()</td><td>获取查询字符串</td></tr><tr><td>void setCharacterEncoding(“utf-8”)</td><td>设置接受参数的字符集</td></tr><tr><td>String getCharacterEncoding()</td><td>返回请求体中的字符编码方式</td></tr><tr><td>String getHeader(String name)</td><td>返回HTTP协议定义的文件头信息</td></tr><tr><td>String getMethod()</td><td>获取客户端向服务器传送数据的方法</td></tr><tr><td>HttpSession getSession()</td><td>返回和请求相关的 Session</td></tr><tr><td>String getServletPath()</td><td>获取客户端所请求的脚本文件的路径</td></tr><tr><td>Cookie[] getCookies()</td><td>返回客户端的所有 Cookie 对象，结果是 Cookie数组</td></tr><tr><td>void removeAttribute(String name)</td><td>删除请求中的一个属性</td></tr></tbody></table><h5 id="getAttribute-与-getParameter-的区别"><a href="#getAttribute-与-getParameter-的区别" class="headerlink" title="getAttribute 与 getParameter 的区别"></a>getAttribute 与 getParameter 的区别</h5><ul><li>从获取方向来看：<ul><li><strong>getParameter() 是获取 POST/GET 传递的参数值</strong></li><li><strong>getAttribute() 是获取对象容器中的数据值</strong></li></ul></li><li>从用途来看：<ul><li><strong>getParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用</strong></li><li><strong>getAttribute用于服务器端重定向时，即在 servlet 中使用了 forward 函数,或 struts 中使用了 mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值</strong></li><li><strong>可以用 setAttribute,getAttribute 发送接收对象</strong></li><li><strong>getParameter 只能传字符串</strong></li></ul></li></ul><p>setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。</p><p>getParameter只是应用服务器在分析你送上来的 request 页面的文本时，取得你设在表单或 url 重定向时的值。</p><p>总结：<br>getParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p><p>getAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用</p><h4 id="response-响应对象常用方法"><a href="#response-响应对象常用方法" class="headerlink" title="response 响应对象常用方法"></a>response 响应对象常用方法</h4><p><strong>隐藏对象 response 是 javax.servlet.ServletResponse 类的实例，代表客户端的响应。服务器端的任何输出都通过 response 对象发送到客户端浏览器。每次服务器端都会响应一个 response 实例</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>String getCharacterEncoding()</td><td>返回响应用的是何种字符编码</td></tr><tr><td>ServletOutputStream getOutputStream()</td><td>返回响应的一个二进制输出流</td></tr><tr><td>PrintWriter getWriter()</td><td>返回可以向客户端输出字符的一个对象</td></tr><tr><td>void setContentLength(int len)</td><td>设置响应头长度</td></tr><tr><td>void setContentType(String type)</td><td>设置响应的 MIME 类型</td></tr><tr><td>sendRedirect(java.lang.String location)</td><td>重新定向客户端的请求</td></tr><tr><td>void setCharacterEncoding(“utf-8”)</td><td>设置响应头的字符集</td></tr></tbody></table><h4 id="Session-会话对象常用方法"><a href="#Session-会话对象常用方法" class="headerlink" title="Session 会话对象常用方法"></a>Session 会话对象常用方法</h4><p><strong>隐藏对象 session 是 javax.servlet.http.HttpSession 类的实例。Servlet 中通过 request.getSession()来获取 session 对象，而 JSP 中可以直接使用。如果JSP中配置了 <code>&lt;%@page session=”false”%&gt;</code> ,则隐藏对象 session 不可用,每个用户对应一个 session 对象</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>long getCreationTime()</td><td>返回Session创建时间</td></tr><tr><td>String getId()</td><td>返回 Session 创建时 JSP 引擎为它设的唯一ID号</td></tr><tr><td>long getLastAccessedTime()</td><td>返回此Session里客户端最近一次请求时间</td></tr><tr><td>int getMaxInactiveInterval()</td><td>返回两次请求间隔多长时间此Session被取消(ms)</td></tr><tr><td>String[] getValueNames()</td><td>返回一个包含此Session中所有可用属性的数组</td></tr><tr><td>void invalidate()</td><td>取消Session,使Session不可用</td></tr><tr><td>boolean isNew()</td><td>返回服务器创建的一个Session,客户端是否已经加入</td></tr><tr><td>void removeValue(String name)</td><td>删除Session中指定的属性</td></tr><tr><td>void setAttribute(String key, Object obj)</td><td>设置Session的属性</td></tr><tr><td>Object getAttribute(String name)</td><td>返回session中属性名为name的对象</td></tr></tbody></table><h4 id="out-输出流对象常用方法"><a href="#out-输出流对象常用方法" class="headerlink" title="out 输出流对象常用方法"></a>out 输出流对象常用方法</h4><p><strong>隐藏对象 out 是 javax.servlet.jsp.JspWriter 类的实例服务器向客户输出的字符内容可以通过 out 对象输出。获取方法：<code>PrintWriter out = response.getWriter()</code></strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void clear()</td><td>清除缓冲区的内容</td></tr><tr><td>void clearBuffer()</td><td>清除缓冲区的当前内容</td></tr><tr><td>void flush()</td><td>将缓冲区内容flush到客户端浏览器</td></tr><tr><td>int getBufferSize()</td><td>返回缓冲大小，单位KB</td></tr><tr><td>int getRemaining()</td><td>返回缓冲剩余大小，单位KB</td></tr><tr><td>isAutoFlush()</td><td>返回缓冲区满时，是自动清空还是抛出异常</td></tr><tr><td>void close()</td><td>关闭输出流</td></tr></tbody></table><h4 id="application-应用程序对象常用方法"><a href="#application-应用程序对象常用方法" class="headerlink" title="application 应用程序对象常用方法"></a>application 应用程序对象常用方法</h4><p><strong>application 封装 JSP 所在 Web 应用程序的信息，例如 web.xml 中配置的全局的初始化信息。Servlet 中 application 对象需要通过ServletConfig.getServletContext() 来获取。整个 Web 应用程序对应一个application 对象</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object getAttribute(String name)</td><td>返回application中属性为name的对象</td></tr><tr><td>Enumeration getAttributeNames()</td><td>返回application中的所有属性名</td></tr><tr><td>void setAttribute(String name,Object value)</td><td>设置application属性</td></tr><tr><td>void removeAttribute(String name)</td><td>移除application属性</td></tr><tr><td>String getInitParameter(String name)</td><td>返回全局初始化函数</td></tr><tr><td>Enumeration getInitParameterNames()</td><td>返回所有的全局初始化参数</td></tr><tr><td>String getMimeType(String filename)</td><td>返回文件的文档类型</td></tr><tr><td>String getRealPath(String relativePath)</td><td>返回Web应用程序内相对网址对应的绝对路径</td></tr></tbody></table><h4 id="page-页面对象"><a href="#page-页面对象" class="headerlink" title="page 页面对象"></a>page 页面对象</h4><p><strong>隐藏对象 page 是 javax.servlet.jsp.HttpJspPage 类的实例。page 对象代表当前 JSP 页面，是当前 JSP 编译后的 Servlet 类的对象。page 相当于 Java 类中的关键字 this</strong></p><h4 id="pageContext-页面上下文对象"><a href="#pageContext-页面上下文对象" class="headerlink" title="pageContext 页面上下文对象"></a>pageContext 页面上下文对象</h4><p><strong>隐藏对象 pageContext 为 javax.servlet.jsp.PageContext 类的实例。pageContext 对象代表当前 JSP 页面编译后的内容。通过 pageContext 能够获取到 JSP 中的资源</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>JspWriter getOut()</td><td>返回out对象</td></tr><tr><td>HttpSession getSession()</td><td>返回Session对象(session)</td></tr><tr><td>Object getPage()</td><td>返回page对象</td></tr><tr><td>ServletRequest getRequest()</td><td>返回request对象</td></tr><tr><td>ServletResponse getResponse()</td><td>返回response对象</td></tr><tr><td>void setAttribute(String name, Object attribute)</td><td>设置属性及属性值 ，在page范围内有效</td></tr><tr><td>void setAttribute(String name,Object obj,int scope)</td><td>在指定范围内设置属性及属性值 ，int1=page,2=request,3=session,4=application</td></tr><tr><td>Object getAttribute(String name)</td><td>返回Web应用程序内相对网址对应的绝对路径</td></tr><tr><td>Object getAttribute(String name,int scope)</td><td>在指定范围内取属性的值</td></tr><tr><td>Object findAttribute(String name)</td><td>寻找一属性,返回起属性值或 NULL</td></tr><tr><td>void removeAttribute(String name)</td><td>删除某属性</td></tr><tr><td>void removeAttribute(String name,int scope)</td><td>在指定范围删除某属性</td></tr><tr><td>int getAttributeScope(String name)</td><td>返回某属性的作用范围</td></tr><tr><td>Enumeration getAttributeNamesInScope(int scope)</td><td>返回指定范围内可用的属性名枚举</td></tr><tr><td>void release()</td><td>释放pageContext所占用的资源</td></tr><tr><td>void forward(String relativeUrlPath)</td><td>使当前页面转发到另一页面</td></tr><tr><td>void include(String relativeUrlPath)</td><td>在当前位置包含另一文件</td></tr></tbody></table><h4 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h4><p><strong>隐藏对象 exception 为 java.lang.Exception 类的对象。exception 封装了 JSP 中抛出的异常信息。要使用 exception 隐藏对象，需要设置 <code>&lt;%@page isErrorPage=&quot;true&quot;%&gt;</code>。隐藏对象 exception 通常被用来处理错误页面</strong></p><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p><strong>隐藏对象 config 是 javax.servlet.ServletConfig 类的实例,ServletConfig 封装了配置在 web.xml 中初始化 JSP 的参数。JSP 中通过 config 获取这些参数。每个 JSP 文件中共有一个 config 对象</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>String getInitParameter(String name)</td><td>返回配置在web.xml中初始化参数</td></tr><tr><td>Enumeration getInitParameterNames()</td><td>返回所有的初始化参数名称</td></tr><tr><td>ServletContext getServletContext()</td><td>返回 ServletContext 对象</td></tr><tr><td>String getServletName()</td><td>返回 Servlet 对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 的异常处理</title>
      <link href="/java/exception.html"/>
      <url>/java/exception.html</url>
      
        <content type="html"><![CDATA[<p><strong>异常指不期而至的各种状况，如：文件找不到、网络连接失败、除0操作、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程</strong></p><blockquote><p>Error 通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这类异常时，JVM 一般会选择终止线程，Exception 通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。，</p></blockquote><a id="more"></a><p><img src="https://images.csthink.com/PPjwP.png" alt="Java 异常类"></p><ul><li>Error: 程序无法处理的系统错误 ，编译器不做检查,属于 JVM 需要负担的责任<ul><li>由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关 </li></ul></li><li>Excepiton: 程序可以处理的异常，捕获后可能恢复<ul><li>运行时异常(RuntimeException): 这些异常是非检查异常(Unchecked Exception),不可预知的，程序应该自行避免,Java 编译器不要求强制处理的异常，在编译阶段不会去检查这类异常</li><li>非运行时异常: 可预知的异常(Checked Exception)，必须处理的异常，否则编译不能通过编译<ul><li>IO异常文件不存在打开的时候出现的异常</li><li>SQL异常</li><li>自定义异常</li></ul></li></ul></li></ul><h2 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h2><ul><li><strong>public string getMessage()</strong>:返回异常发生时的详细信息</li><li><strong>public string toString()</strong>:返回异常发生时的简要描述</li><li><strong>public string getLocalizedMessage()</strong>:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li><li><strong>public void printStackTrace()</strong>:在控制台上打印Throwable对象封装的异常信息</li></ul><h2 id="常见-Exception-和-Error-的描述"><a href="#常见-Exception-和-Error-的描述" class="headerlink" title="常见 Exception 和 Error 的描述"></a>常见 Exception 和 Error 的描述</h2><h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a><strong>RuntimeException</strong></h3><ol><li>NullPointerException - 空指针引用异常</li><li>ClassCastException - 类型强制转换异常</li><li>IllegalArgumentException - 传递非法参数异常</li><li>IndexOutOfBoundsException - 下标越界异常</li><li>ArrayIndexOutOfBoundsException - 数组下标越界</li><li>NumberFormatException - 数字格式异常</li><li>ArithmeticException - 算术异常</li><li>MissingResourceException - 丢失资源</li></ol><h3 id="非RuntimeException"><a href="#非RuntimeException" class="headerlink" title="非RuntimeException"></a><strong>非RuntimeException</strong></h3><ol><li>IOException - IO操作异常</li><li>FileNotFoundException</li><li>SQLException - SQL 异常</li><li>ClassNotFoundException - 找不到类</li></ol><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a><strong>Error</strong></h3><ol><li>NoClassDefFoundError - 类定义错误</li><li>StackOverflowError - 深递归导致栈被耗尽</li><li>OutOfMemoryError - 内存溢出</li><li>VirtualMachineError - 虚拟机错误</li><li>ThreadDeath - 线程死锁</li><li>LinkageError - 链接错误</li></ol><h4 id="NoClassDefFoundError的成因"><a href="#NoClassDefFoundError的成因" class="headerlink" title="NoClassDefFoundError的成因"></a><strong>NoClassDefFoundError的成因</strong></h4><ol><li>类依赖的class或jar不存在</li><li>类文件存在，但是存在不同的域中</li><li>大小写问题，javac编译的时候无视大小写，很有可能编译出来的class文件就与想要的不一样</li></ol><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p><strong>对于Checked Exception 必须捕获或声明抛出，对于UnChecked Exception及其子类可忽略不检查</strong></p><ol><li>抛出异常: 创建异常对象，交由运行时系统处理</li><li>捕获异常: 在方法抛出异常之后,运行时系统寻找合适的异常处理器处理异常，若未能找到合适的异常处理器则运行时系统终止运行</li></ol><h3 id="try、catch、finally、throw、throws"><a href="#try、catch、finally、throw、throws" class="headerlink" title="try、catch、finally、throw、throws"></a>try、catch、finally、throw、throws</h3><ul><li>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块</li><li>catch 块：用于处理try捕获到的异常</li><li>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行</li><li>throw: 抛出明确的异常</li><li>throws: 如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常，可以在方法声明中包含一个throws子句</li></ul><p><img src="https://images.csthink.com/15547746383189.jpg" alt="try、catch、finally、throw、throws"></p><h4 id="在以下4种特殊情况下，finally-块不会被执行："><a href="#在以下4种特殊情况下，finally-块不会被执行：" class="headerlink" title="在以下4种特殊情况下，finally 块不会被执行："></a><strong>在以下4种特殊情况下，finally 块不会被执行：</strong></h4><ol><li>在 finally 语句块中发生了异常</li><li>在前面的代码中用了 System.exit()退出程序</li><li>程序所在的线程死亡</li><li>关闭 CPU</li></ol><h4 id="关于返回值："><a href="#关于返回值：" class="headerlink" title="关于返回值："></a><strong>关于返回值：</strong></h4><p>如果 try 语句里有 return，返回的是 try 语句块中变量值。 详细执行过程如下：</p><ol><li>如果有返回值，就把返回值保存到局部变量中</li><li>执行 jsr 指令跳到 finally 语句里执行</li><li>执行完 finally 语句后，返回之前保存在局部变量里的值</li><li>如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的return</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计原则-上</title>
      <link href="/java/desing_principle_part_one.html"/>
      <url>/java/desing_principle_part_one.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在程序设计领域， SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）是由罗伯特·C·马丁在21世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。</p></blockquote><a id="more"></a><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><blockquote><p>定义: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭</p></blockquote><ul><li>用抽象构建框架，用实现扩展细节</li><li>优点: 提高软件系统的可复用性及可维护性</li><li>实现核心： 面向抽象编程</li></ul><h3 id="Code-演示"><a href="#Code-演示" class="headerlink" title="Code 演示"></a>Code 演示</h3><p><img src="https://images.csthink.com/openclose.png" alt="开闭原则实现"></p><p><img src="https://images.csthink.com/cc.png" alt="JavaCourse 实现类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2009.52.32.png" alt="JavaDiscountCourse 子类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2010.00.55.png" alt="测试类"></p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><blockquote><p>定义: 高层模块不应该依赖低层模块，二者都应该依赖其抽象</p></blockquote><ul><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>针对接口编程，不要针对实现编程</li><li>优点: 可以减少类间的耦合性，提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的风险</li></ul><h3 id="Code-演示-1"><a href="#Code-演示-1" class="headerlink" title="Code 演示"></a>Code 演示</h3><p><img src="https://images.csthink.com/Package%20dependencyInversion.png" alt="依赖倒置原则实现"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2014.32.39.png" alt="接口"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2014.23.17.png" alt="实现类1"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2014.23.41.png" alt="实现类2"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2014.24.08.png" alt="实现类3"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2014.26.00.png" alt="业务类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2014.26.30.png" alt="测试类,高层模块"></p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><blockquote><p>定义: 不要存在多于一个导致类变更的原因</p></blockquote><ul><li>一个类/接口/方法只负责一项职责</li><li>优点: 降低类的复杂度、提高类的可读性，提高系统的可维护性、降低变更引起的风险</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h4 id="类没有使用单一职责"><a href="#类没有使用单一职责" class="headerlink" title="类没有使用单一职责"></a>类没有使用单一职责</h4><p><strong>这个例子中的 Bird 类同时为两种鸟类移动的行为负责，每次增加或修改一个鸟类都会影响到其他鸟类的行为</strong></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.02.55.png" alt="Bird类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.04.27.png" alt="测试类"></p><h4 id="类应用单一职责原则"><a href="#类应用单一职责原则" class="headerlink" title="类应用单一职责原则"></a>类应用单一职责原则</h4><p><strong>这个例子中每种鸟都有自己的行为类负责，增加或修改某个鸟类，不会影响到其他的鸟类</strong></p><p><img src="https://images.csthink.com/Package%20singleresponsibility.png" alt="类遵循了单一职责原则设计"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.05.06.png" alt="会飞的鸟类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.05.41.png" alt="用脚走路的鸟类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.06.17.png" alt="测试类"></p><h4 id="接口没有遵循单一职责原则"><a href="#接口没有遵循单一职责原则" class="headerlink" title="接口没有遵循单一职责原则"></a>接口没有遵循单一职责原则</h4><p><strong>下面这个接口没有遵循单一职责原则，<code>getCourseName()</code> 与 <code>getCourseVideo</code> 属于课程信息相关的职责，而 <code>studyCourse()</code> 与<code>refundCourse()</code>却属于课程管理相关的职责</strong></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.10.58.png" alt="没有遵循单一职责的接口"></p><h4 id="接口遵循单一职责原则"><a href="#接口遵循单一职责原则" class="headerlink" title="接口遵循单一职责原则"></a>接口遵循单一职责原则</h4><p><img src="https://images.csthink.com/Package%20singleresponsibility.png" alt="接口遵循了单一职责原则设计"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.14.22.png" alt="课程信息接口"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.14.44.png" alt="课程管理接口"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.15.29.png" alt="实现类实现两个课程相关的接口"></p><h4 id="方法采用单一职责原则"><a href="#方法采用单一职责原则" class="headerlink" title="方法采用单一职责原则"></a>方法采用单一职责原则</h4><p><img src="https://images.csthink.com/Carbonize%202019-04-16%20at%2015.22.11.png" alt="方法的单一职责原则"></p><h3 id="单一职责原则的总结"><a href="#单一职责原则的总结" class="headerlink" title="单一职责原则的总结"></a>单一职责原则的总结</h3><p>单一职责原则告诉我们: <strong>一个类不能太”累”</strong>，在软件系统中，一个类(大到模块，小到方法)承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，将相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一个类中。</p><p>实际项目开发过程中，如果所有的类、接口、方法都遵循单一职责原则，可能会导致类的数量巨大，结合项目的开发周期，开发人员代码水平的不同，不可能让类、接口、方法都遵循单一职责原则，但我们应尽量保证接口与方法遵循单一职责原则。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面向对象</title>
      <link href="/java/oop.html"/>
      <url>/java/oop.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p><strong>优点</strong>：性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发</p><p><strong>缺点</strong>： 没有面向对象易维护、易复用、易扩展</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>优点</strong>： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p><p><strong>缺点</strong>： 性能比面向过程低</p><a id="more"></a><h3 id="类、对象"><a href="#类、对象" class="headerlink" title="类、对象"></a>类、对象</h3><p><strong>类是模板，确定对象将会拥有的特征(属性)和行为(方法)</strong></p><h4 id="类的特点"><a href="#类的特点" class="headerlink" title="类的特点"></a>类的特点</h4><ul><li>类是对象的类型</li><li>具有相同属性和方法的一组对象的集合<ul><li>属性: 对象具有的各种静态特征(“有什么”)</li><li>方法: 对象具有的各种动态行为(“能做什么”)</li></ul></li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>对象是运行期的基本实体，它是一个封装了数据和操作这些数据的代码的逻辑实体</strong></p><h5 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h5><ul><li><p>声明对象  <code>Person p</code></p></li><li><p>实例化对象 <code>new Person();</code></p></li><li><p><code>Person p = new Person();</code></p></li><li><p>每次 new 对象都会产生新的实例化对象</p></li><li><p>多个对象可以指向同一块实例化空间</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = p1;</span><br></pre></td></tr></table></figure></li><li><p>对象必须被实例化后才能使用</p></li><li><p>对象间的引用传递，实际上传递的是堆内存空间的使用权</p></li></ul><h6 id="匿名对象的创建和使用方法"><a href="#匿名对象的创建和使用方法" class="headerlink" title="匿名对象的创建和使用方法"></a>匿名对象的创建和使用方法</h6><p>可以不定义对象的引用名称，而直接调用这个对象的方法。这样的对象叫做<strong>匿名对象</strong>,匿名对象通常都是一次性的。</p><p><code>new Person().eat();</code></p><h6 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h6><ol><li>对象.成员变量</li><li>对象.成员方法()</li></ol><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>主要用来在创建对象时初始化对象,即为对象的成员变量赋初始值</strong></p><ul><li>构造方法与类同名且没有返回值，但不能使用 void 关键字</li><li>在对象实例化时调用</li><li><strong>当没有指定构造方法时，编译器会在编译时自动添加无参数且方法体为空的构造方法</strong></li><li>当有指定构造方法时，无论是有参还是无参，系统都不会自动添加无参的构造方法</li><li>一个类中可以有多个构造方法(构造函数的重载)</li></ul><h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><p><strong>父类的私有属性和构造方法并不能被继承，所以构造器 Constructor 就不能被重写(override),但是可以被重载(overload),所以你可以看到一个类中有多个构造函数的情况</strong></p><h4 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h4><p><strong>发生在同一个类中，方法名相同，参数类型、个数、顺序至少有一处不同</strong></p><ul><li>返回值不同，其它都相同不构成重载关系</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2014.48.29.png" alt="重载"></p><h4 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h4><p><strong>发生在继承体关系中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类</strong></p><ul><li>使用 @Override 注解，可以让编译器帮忙检查是否满足重载的限制条件</li><li>如果父类方法访问修饰符为 private 则子类就不能重写该方法</li></ul><h5 id="重写的例子"><a href="#重写的例子" class="headerlink" title="重写的例子"></a>重写的例子</h5><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2012.36.39.png" alt="重写"></p><ul><li>子类方法访问权限为 public，大于父类的 protected。</li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li><li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件</li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><strong>为 JAVA 类提供了命名空间，用于管理 Java 文件，解决同名文件冲突</strong></p><ul><li>package 包名; 必须放在Java源文件中的第一行</li><li>一个Java源文件只能有一个 package 语句</li><li>包名命名采用全英文小写，命名规则: 域名倒序 + 模块 + 功能</li><li>一个类的全名应该是 ”包名.类名”</li><li>使用javac 编译时需要使用 -d 参数，该参数的作用是依据包名生成相应的文件夹</li></ul><h4 id="导入bao"><a href="#导入bao" class="headerlink" title="导入bao"></a>导入bao</h4><ul><li>import 包名.类名;</li><li>import com.csthink.*; 导入包中全部类</li><li>import com.csthink.utils.JdbcUtils; 导入包中指定类</li></ul><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p><strong>当前对象的默认引用</strong></p><h4 id="this-的使用"><a href="#this-的使用" class="headerlink" title="this 的使用"></a>this 的使用</h4><ul><li>调用成员变量，解决成员变量与局部变量同名问题</li><li>调用成员方法</li><li>调用重载的构造方法</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2012.45.58.png" alt="this 的使用"></p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>静态成员随类加载产生，直至类销毁才回收</p><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><ul><li>静态变量又称为类变量，该变量属于类，类所有的实例都共享静态变量，可以直接通过类名访问它，静态变量在内存中只存在一份</li><li>实例变量，每创建一个实例就会产生一个实例变量，它与该实例同生共死</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2013.46.10.png" alt="静态变量"></p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p><strong>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法</strong></p><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2013.52.03.png" alt="静态方法"></p><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p><strong>静态代码块在类初始时运行，只会运行一次</strong></p><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2013.54.46.png" alt="静态代码块"></p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><strong>非静态内部类依赖于外部类的实例，而静态内部类不需要</strong></p><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2013.59.14.png" alt="静态内部类"></p><h4 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h4><p><strong>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*;</span><br></pre></td></tr></table></figure><h4 id="静态变量、静态代码块、普通代码块、实例变量、构造方法的初始化顺序"><a href="#静态变量、静态代码块、普通代码块、实例变量、构造方法的初始化顺序" class="headerlink" title="静态变量、静态代码块、普通代码块、实例变量、构造方法的初始化顺序"></a>静态变量、静态代码块、普通代码块、实例变量、构造方法的初始化顺序</h4><p><strong>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</strong></p><p>存在继承的情况下，初始化顺序为：</p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制</strong></p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor ：可以用 Constructor 创建新的对象。</li></ul><h4 id="一个反射的例子-通过反射去访问类属性、成员方法"><a href="#一个反射的例子-通过反射去访问类属性、成员方法" class="headerlink" title="一个反射的例子(通过反射去访问类属性、成员方法)"></a>一个反射的例子(通过反射去访问类属性、成员方法)</h4><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2014.34.47.png" alt="Robot 实体类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2014.36.54.png" alt="反射操作"></p><h3 id="抽象类和抽象函数"><a href="#抽象类和抽象函数" class="headerlink" title="抽象类和抽象函数"></a>抽象类和抽象函数</h3><h4 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h4><p>抽象函数就是只有函数的定义，没有函数体的函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="抽象类-天生当爹的"><a href="#抽象类-天生当爹的" class="headerlink" title="抽象类(天生当爹的)"></a>抽象类(天生当爹的)</h4><p><strong>抽象类也称为基类，它只能作为父类被子类继承。在子类中需复写抽象类中的抽象函数，以便子类在继承</strong></p><ul><li><strong>抽象类不能够生成对象</strong><ul><li>也就是不能调用这个类的构造函数来生成对象</li><li>如果抽象类能生成对象，则意味着该对象也将会调用其中的抽象函数，而抽象函数是没有函数体的，这也将导致该调用的失败。所以不能调用抽象类来生成对象</li></ul></li><li>如果一个类当中包含有抽象函数，这个类必须被声明为抽象类</li><li>一个类当中没有包含抽象函数，这个类也可以被声明为抽象类</li><li><strong>抽象类也是有构造函数的，而且子类的构造函数同样会调用抽象父类的构造函数</strong></li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2015.14.15.png" alt="抽象类"></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>需要在几个相关的类中共享代码</li><li>需要能控制继承来的成员的访问权限，而不是都为 public</li><li>需要继承非静态和非常量字段</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现,从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类</strong></p><ul><li>使用 interface 定义</li><li>接口当中的方法都是抽象方法</li><li>接口当中的方法都是 public 权限,方法可以不用手动使用 public 修饰</li><li>实现接口使用 implements 关键字</li><li>一个类可以实现多个接口</li><li>一个接口可以继承多个接口</li><li>接口的字段默认都是 static 和 final 的</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2015.23.51.png" alt="接口"></p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承</li></ul><h2 id="面向对象编程三大特性-封装-继承-多态"><a href="#面向对象编程三大特性-封装-继承-多态" class="headerlink" title="面向对象编程三大特性: 封装 继承 多态"></a>面向对象编程三大特性: 封装 继承 多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装把一个对象的属性私有化，同时提供一些可以被外界访问属性的方法</strong></p><ul><li>将类的某些信息隐藏在类内部，不允许外部程序直接访问</li><li>通过该类提供的方法来实现对隐藏信息的操作和方法</li><li>隐藏类的实例细节，方便修改和实现</li><li>留出访问的接口，通过规定的方法来访问数据</li></ul><h4 id="封装实现的步骤"><a href="#封装实现的步骤" class="headerlink" title="封装实现的步骤"></a>封装实现的步骤</h4><ul><li>修改成员属性的可见性为 private</li><li>创建 getter/setter 方法，可见性为 public,用于对属性的访问</li><li>在 getter/setter 方法中加入属性控制语句</li></ul><h4 id="public-公共权限"><a href="#public-公共权限" class="headerlink" title="public 公共权限"></a>public 公共权限</h4><ul><li>公共权限的类，其类名必须与源文件的文件名保持一致</li><li>只有声明为公共权限的类，才能在不同的包中进行访问</li></ul><h4 id="private-私有权限"><a href="#private-私有权限" class="headerlink" title="private    私有权限"></a>private    私有权限</h4><ul><li>一般情况下，私有权限仅用于修饰成员函数和成员变量</li><li>private 修饰的成员函数和成员变量只能在当前的类当中使用</li></ul><h4 id="default-包级别访问权限-默认权限"><a href="#default-包级别访问权限-默认权限" class="headerlink" title="default    包级别访问权限/默认权限"></a>default    包级别访问权限/默认权限</h4><ul><li>此权限无需在类名、变量名或函数名前面使用权限修饰符 default</li><li>在不同的包里面，不能访问 default 权限的类</li></ul><h4 id="protected-受保护权限"><a href="#protected-受保护权限" class="headerlink" title="protected    受保护权限"></a>protected    受保护权限</h4><ul><li>protected 用于修饰成员，表示在继承体系中父类成员对于子类可见，但是这个访问修饰符对于类没有意义</li><li>protected 权限拥有和 default 权限一样的功能</li><li>protected 权限可以跨包进行使用</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，<strong>JAVA 仅支持单继承</strong>，即一个子类只允许继承一个父类，但一个父类可以拥有多个子类。</p><ul><li>子类拥有父类非 private 的属性和方法</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展</li><li>子类可以用自己的方式实现父类的方法</li><li>父类的构造方法不能被继承</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2014.54.17.png" alt="继承"></p><h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作，super() 必须是子类构造方法的第一行</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现，super.父类xx方法()</li></ul><h4 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h4><ul><li>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量<ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改</li></ul></li><li>声明方法不能被子类重写<ul><li>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法</li></ul></li><li>声明类不允许被继承</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态是指不同事物具有不同表现形式的能力。多态机制使具有不同内部结构的对象可以共享相同的外部接口，通过这种方式减少代码的复杂度</strong></p><p>所谓多态就是指程序中定义的<strong>引用变量所指向的具体类型和通过该引用变量调用的方法</strong>在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象及该引用变量调用的方法到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：</p><ul><li>继承（多个子类对同一方法的重写）</li><li>接口（实现接口并覆盖接口中同一方法）</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 类集框架</title>
      <link href="/java/collection.html"/>
      <url>/java/collection.html</url>
      
        <content type="html"><![CDATA[<h2 id="List、Set、Map三者的区别及总结"><a href="#List、Set、Map三者的区别及总结" class="headerlink" title="List、Set、Map三者的区别及总结"></a>List、Set、Map三者的区别及总结</h2><ul><li><p><strong>List: 对付顺序的好帮手</strong></p><p>List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p></li><li><p><strong>Set: 注重独一无二的性质</strong></p><p>不允许重复的集合，不会有多个元素引用相同的对象。</p></li><li><p><strong>Map: 用Key来搜索的专家</strong></p><p>使用键值对存储，Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p><a id="more"></a></li></ul><p><img src="https://images.csthink.com/15546359120650.jpg" alt="集合框架"><br><img src="https://images.csthink.com/15546363481380.jpg" alt="List 与 Set"></p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul><li>可以统一的方式对各种集合元素进行遍历</li><li>hasNext() 方法检测集合中是否还有下一个元素</li><li>next() 方法返回集合中的下一个元素</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>存储一组不唯一(可以有多个元素引用相同的对象)，有序的对象</strong></p><ul><li>List 是元素有序并且可以重复的集合，称为序列</li><li>List 可以精确的控制每个元素的插入位置，或删除某个位置的的元素</li><li>List 两个主要实现类是 ArrayList 和 LinkedList</li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li>ArrayList 底层是由数组实现</li><li>动态增长</li><li>查询快，增删慢，增删元素的时间复杂度近似O(n)</li><li>线程不安全，效率高</li><li>ArrayList 中的元素可以为 null</li><li>一般推荐使用 ArrayList</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2008.55.30.png" alt="ArrayList"></p><h4 id="两个集合取交集、并集、差集"><a href="#两个集合取交集、并集、差集" class="headerlink" title="两个集合取交集、并集、差集"></a>两个集合取交集、并集、差集</h4><ul><li>addAll(Collection&lt;? extends E&gt; c) :按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾<br>实例代码：</li><li>retainAll(Collection&lt;?&gt; c): 仅保留此列表中包含在指定集合中的元素。</li><li>removeAll(Collection&lt;?&gt; c) :从此列表中删除指定集合中包含的所有元素。 </li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2010.16.53.png" alt="两个集合取交集、并集、差集"></p><h4 id="数组与List之间的转换"><a href="#数组与List之间的转换" class="headerlink" title="数组与List之间的转换"></a>数组与List之间的转换</h4><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2010.44.33.png" alt="数组与List之间的转换"></p><h3 id="Vector-底层是数组，查询快，增删慢，线程安全效率低"><a href="#Vector-底层是数组，查询快，增删慢，线程安全效率低" class="headerlink" title="Vector 底层是数组，查询快，增删慢，线程安全效率低"></a>Vector <strong>底层是数组，查询快，增删慢，线程安全效率低</strong></h3><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li>与ArrayList一样，也按照索引位置排序，底层使用的是双向链表</li><li>查询慢，增删快,增删元素的时间复杂度不受元素位置的影响，都是近似O（1）</li><li>线程安全，效率低</li><li>数据特别多，而且经常需要插入删除元素时建议选用LinkedList</li><li>LinkedList 实现 List 和 Queue 两个接口</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2009.22.57.png" alt="LinkedList"></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>元素无序且不可重复的集合，被称为集</strong></p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>HashSet 是 Set的一个重要实现类，称为哈希集或散列集</li><li>HashSet 中的元素无序且不可重复，唯一性</li><li>HashSet 中只允许一个null元素</li><li>具有良好的查找和存储性能</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2008.59.58.png" alt="HashSet"></p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p><strong>底层由链表和哈希表组成,由链表保证元素的排序,由哈希表证元素的唯一性</strong></p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><strong>有序，唯一,红黑树(自平衡的排序二叉树)</strong></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><strong>键值对形式存储</strong></p><ul><li>Map 中的数据是 key-value 形式存储</li><li>key-value 以 Entry 类型的对象实例存在</li><li>通过 key 可以快速地找到value</li><li>一个映射不能包含重复的键，但两个Key可以引用相同的对象</li><li>每个键最多只能映射到一个值</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>基于哈希表的 Map 接口的实现(哈希表对键进行散列，Map结构即映射表存放键值对)</li><li>运行使用 null 值 和 null 键</li><li>key 值不允许重复</li><li>HashMap中的Entry对象是无序排列</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2009.14.10.png" alt="HashMap"></p><h3 id="LinkedHashMap-HashMap的基础上加上了链表数据结构"><a href="#LinkedHashMap-HashMap的基础上加上了链表数据结构" class="headerlink" title="LinkedHashMap HashMap的基础上加上了链表数据结构"></a>LinkedHashMap <strong>HashMap的基础上加上了链表数据结构</strong></h3><h3 id="HashTable-哈希表"><a href="#HashTable-哈希表" class="headerlink" title="HashTable 哈希表"></a>HashTable <strong>哈希表</strong></h3><h3 id="TreeMap-红黑树（自平衡的排序二叉树"><a href="#TreeMap-红黑树（自平衡的排序二叉树" class="headerlink" title="TreeMap 红黑树（自平衡的排序二叉树"></a>TreeMap <strong>红黑树（自平衡的排序二叉树</strong></h3><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p><strong>使用LinkedList对自定义类进行管理</strong></p><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2009.41.59.png" alt="Student 实体类"></p><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2009.43.19.png" alt="LinkedList 实现 Queue接口"></p><p>执行结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Student&#123;name='Jim', age=19, gender='男'&#125;, Student&#123;name='Lucy', age=19, gender='女'&#125;, Student&#123;name='梅梅', age=18, gender='女'&#125;]</span><br><span class="line">pop方法移除的元素: Student&#123;name='Jim', age=19, gender='男'&#125;</span><br><span class="line">执行pop方法后: [Student&#123;name='Lucy', age=19, gender='女'&#125;, Student&#123;name='梅梅', age=18, gender='女'&#125;]</span><br><span class="line">peak方法获取的元素: Student&#123;name='梅梅', age=18, gender='女'&#125;</span><br><span class="line">执行peak方法后: [Student&#123;name='梅梅', age=18, gender='女'&#125;, Student&#123;name='Lucy', age=19, gender='女'&#125;, Student&#123;name='梅梅', age=18, gender='女'&#125;]</span><br><span class="line">poll方法获取元素的同时，并删除元素: Student&#123;name='梅梅', age=18, gender='女'&#125;</span><br><span class="line">执行poll方法后:[Student&#123;name='Lucy', age=19, gender='女'&#125;, Student&#123;name='梅梅', age=18, gender='女'&#125;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/java/basic.html"/>
      <url>/java/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://images.csthink.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-09%2009.01.36.png" alt="数据类型"></p><a id="more"></a><h3 id="基本数据类型的默认值"><a href="#基本数据类型的默认值" class="headerlink" title="基本数据类型的默认值"></a>基本数据类型的默认值</h3><table><thead><tr><th align="center">基本数据类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">0</td></tr><tr><td align="center">short</td><td align="center">0</td></tr><tr><td align="center">int</td><td align="center">0</td></tr><tr><td align="center">long</td><td align="center">0L</td></tr><tr><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">dobule</td><td align="center">0.0d</td></tr><tr><td align="center">char</td><td align="center">‘\u0000’</td></tr><tr><td align="center">boolean</td><td align="center">false</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p><strong>解决基本数据类型不具备对象化能力的问题</strong></p><ul><li>拥有属性、方法</li><li>可以对象化交互</li><li>默认值为 null</li></ul><h3 id="基本数据对应的包装类"><a href="#基本数据对应的包装类" class="headerlink" title="基本数据对应的包装类"></a>基本数据对应的包装类</h3><table><thead><tr><th align="center">基本类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">dobule</td><td align="center">Double</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr></tbody></table><h3 id="基本数据类型与包装类之间的转换"><a href="#基本数据类型与包装类之间的转换" class="headerlink" title="基本数据类型与包装类之间的转换"></a>基本数据类型与包装类之间的转换</h3><ul><li>装箱: 基本数据类型转换为包装类</li><li>拆箱: 包装类转换为对应的基本数据类型</li></ul><h2 id="装箱与拆箱的使用"><a href="#装箱与拆箱的使用" class="headerlink" title="装箱与拆箱的使用"></a>装箱与拆箱的使用</h2><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2006.34.18.png" alt="装箱与拆箱"></p><h2 id="基本数据类型与字符串之间的转换"><a href="#基本数据类型与字符串之间的转换" class="headerlink" title="基本数据类型与字符串之间的转换"></a>基本数据类型与字符串之间的转换</h2><p><img src="https://images.csthink.com/Carbonize%202019-04-08%20at%2006.34.52.png" alt="基本数据类型与字符串之间的转换"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>; <span class="comment">// 定义字符串方式一</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// 定义字符串方式二</span></span><br><span class="line"><span class="keyword">byte</span>[] arrs = s2.getBytes(); <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(arrs); <span class="comment">// 字节数组转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换时可以设置编码类型</span></span><br><span class="line"><span class="comment">// byte[] arrs = s2.getBytes("GBK"); </span></span><br><span class="line"><span class="comment">// String s3 = new String(arrs, "GBK");</span></span><br></pre></td></tr></table></figure><h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">int length()</td><td align="left">返回当前字符串的长度</td></tr><tr><td align="left">int indexOf(int ch)</td><td align="left">查找ch字符在该字符串中第一次出现的位置</td></tr><tr><td align="left">int indexOf(String str)</td><td align="left">查找str子字符串在该字符串中第一次出现的位置</td></tr><tr><td align="left">int lastIndexOf(int ch)</td><td align="left">查找ch字符在该字符串中最后一次出现的位置</td></tr><tr><td align="left">int lastIndexOf(String str)</td><td align="left">查找str子字符串在该字符串中最后一次出现的位置</td></tr><tr><td align="left">String subString(int beginIndex)</td><td align="left">获取从beginIndex位置开始到结束的子字符串</td></tr><tr><td align="left">String subString(int beginIndex, int endIndex)</td><td align="left">获取从beginIndex位置开始到endIndex位置的子字符串</td></tr><tr><td align="left">String trim()</td><td align="left">返回去除了前后空格的字符串</td></tr><tr><td align="left">boolean equals(Object obj)</td><td align="left">将该字符串与指定对象比较，返回true或false</td></tr><tr><td align="left">String toLowerCase()</td><td align="left">将字符串转换为小写</td></tr><tr><td align="left">String toUpperCase()</td><td align="left">将字符串转换为大写</td></tr><tr><td align="left">char charAt(int index)</td><td align="left">获取字符串中指定位置的字符</td></tr><tr><td align="left">String[] split()</td><td align="left">将字符串分割为子字符串，返回字符串数组</td></tr><tr><td align="left">Byte[] getBytes</td><td align="left">将该字符串转换为byte数组</td></tr></tbody></table><h3 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="== 与 equals 的区别"></a><code>==</code> 与 <code>equals</code> 的区别</h3><ul><li><code>==</code>指引用是否相同,是对内存地址的进行的比较，判断的是两个变量或实例是不是指向同一个内存地址空间</li><li><code>equals()</code>指的是值是否相同，是对字符串的内容进行比较,判断的是两个变量或实例所指向的内存空间的值是不是相同</li></ul><h3 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h3><p><strong>String 对象一旦被创建，则不能修改，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不变</strong></p><h3 id="缓存池-字符串常量池-String-Pool"><a href="#缓存池-字符串常量池-String-Pool" class="headerlink" title="缓存池(字符串常量池, String Pool)"></a>缓存池(字符串常量池, String Pool)</h3><p>在Java8中，Integer 缓存池的大小默认为 -128~127,编译器会在自动装箱过程调用valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p><p>new Integer(123) 与 Integer.valueOf(123)的区别在与</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2006.49.51.png" alt="缓存池"></p><h3 id="String不可变的底层实现"><a href="#String不可变的底层实现" class="headerlink" title="String不可变的底层实现"></a>String不可变的底层实现</h3><p>在 Java 8 中，String 内部使用 char数组来存储字符</p><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2006.58.08.png" alt="String不可变的底层实现-Java8"></p><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2006.58.57.png" alt="String不可变的底层实现-Java9"></p><h3 id="String-不可变带来的好处"><a href="#String-不可变带来的好处" class="headerlink" title="String 不可变带来的好处"></a>String 不可变带来的好处</h3><ul><li>可以缓存hash值<ul><li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 </li></ul></li><li>String Pool<ul><li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool</li></ul></li><li>安全性<ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是</li></ul></li><li>线程安全<ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li></ul></li></ul><h3 id="String-不可变例子"><a href="#String-不可变例子" class="headerlink" title="String 不可变例子"></a>String 不可变例子</h3><p><img src="https://images.csthink.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-09%2009.12.59.png" alt="String 不可变例子"></p><ul><li>str1 与 str2 的内容与地址都相同，指向的都是内存常量池里同一份字符串</li><li>str1 或 str2 与 str3或str4的内容是相同的，但是地址是不同的</li><li>str3 与 str4 内容相同，地址不同</li></ul><h3 id="String，StringBuilder-，StringBuffer"><a href="#String，StringBuilder-，StringBuffer" class="headerlink" title="String，StringBuilder ，StringBuffer"></a>String，StringBuilder ，StringBuffer</h3><p><strong>频繁使用大量字符串时，推荐使用 StringBuilder</strong></p><ul><li>String 具有不可变性，而StringBuilder 和 StringBuffer 不具备</li><li>String 的不可变性会在缓存池产生很多废弃的字符串，所以当频繁操作字符串时，应使用StringBuilder(循环中拼接字符串)或 StringBuffer</li><li>String 不可变，因此是线程安全的，StringBuilder 不是线程安全，StringBuffer 是线程安全，其内部使用的 synchronized 进行同步</li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-09%20at%2008.16.05.png" alt="String，StringBuilder ，StringBuffer"></p><h2 id="float-与-dobule"><a href="#float-与-dobule" class="headerlink" title="float 与 dobule"></a>float 与 dobule</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br><span class="line"><span class="comment">//float f = 1.1; // 1.1 字面量属于double类型，不能直接赋值给float</span></span><br><span class="line"><span class="keyword">double</span> f = <span class="number">1.1</span>;</span><br></pre></td></tr></table></figure><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 不能隐式地将 int 类型下转型为 short 类型</span></span><br><span class="line"><span class="comment">//s = s + 1; </span></span><br><span class="line"></span><br><span class="line">s = (<span class="keyword">short</span>) (s + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 使用 += 或 ++ 这类运算符可以执行隐式类型转换</span></span><br><span class="line">s += <span class="number">1</span>; </span><br><span class="line">s++;</span><br></pre></td></tr></table></figure><p>参考: <a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting" target="_blank" rel="noopener">https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 中搭建LNMP</title>
      <link href="/linux/lnmp.html"/>
      <url>/linux/lnmp.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><ul><li><p>CentOS 7 系统</p></li><li><p>su - 切换到root环境下安装以下软件，这里会指定软件的运行身份是 www</p><a id="more"></a></li><li><p>以下软件安装过程中，CentOS 使用的 shell 环境是 zsh，并使用 oh my zsh 插件，所以环境变量都会保存在 ~/.zshrc 文件，应根据系统调整环境变量的保存路径</p></li><li><p>创建一个不能登录的用户</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd www &amp;&amp; useradd -M -s /sbin/nologin  -g www www</span><br></pre></td></tr></table></figure></li><li><p>时间, 日期设置</p></li><li><p>selinux 关闭(可选)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 永久关闭</span><br><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure></li></ul><p>修改  SELINUX=disabled 需重启<br>临时关闭:设置SELinux 成为permissive模式，setenforce 1 设置SELinux 成为enforcing模式 <code>setenforce 0</code></p><ul><li><p>安装常用工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc gcc-c++ make cmake automake autoconf vim git wget nettools telnet tree -y</span><br></pre></td></tr></table></figure></li><li><p>创建 www 目录,并授权</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /var/www \</span><br><span class="line">&amp;&amp; chown -R www:www /var/www</span><br></pre></td></tr></table></figure></li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ol><li><p>依赖软件包安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install pcre pcre-devel perl-ExtUtils-Embed zlib zlib-devel libtool openssl openssl-devel -y</span><br></pre></td></tr></table></figure></li><li><p>下载源码包并解压</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp \</span><br><span class="line">&amp;&amp; wget https://nginx.org/download/nginx-1.14.0.tar.gz \</span><br><span class="line">&amp;&amp; tar -zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nginx-1.14.0 \</span><br><span class="line">  &amp;&amp; ./configure --prefix=/usr/local/nginx \</span><br><span class="line">--user=www \</span><br><span class="line">--group=www \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_ssl_module</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j `grep processor /proc/cpuinfo | wc -l` &amp;&amp; make install &amp;&amp; make clean</span><br></pre></td></tr></table></figure></li><li><p>注册环境变量(有以下两种方式，任选其一)</p><ul><li><p>方式一：注册环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e '\nexport PATH=/usr/local/nginx/sbin:$PATH\n'  &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><p>方式二：创建别名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 'nginx="/usr/local/nginx/sbin/nginx"' &gt;&gt;  ~/.zshrc &amp;&amp; source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建 nginx 所需目录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 创建 Nginx 日志保存目录</span><br><span class="line">mkdir /var/log/nginx/ </span><br><span class="line">chown -R www:www /var/log/nginx</span><br></pre></td></tr></table></figure></li><li><p>配置 nginx.conf</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv nginx.conf nginx.conf.backup # 备份</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -v "#" nginx.conf.backup &gt; nginx.conf # 过滤输出</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p> 参考如下 nginx.conf 配置</p> <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> www;</span><br><span class="line"><span class="comment">#nginx 使用的线程数, cpu核数 * 2 最佳.</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">4</span>;</span><br><span class="line"><span class="comment">#并发请求时使用线程的顺序, 用二进制位表示.</span></span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> <span class="number">01</span> <span class="number">10</span> <span class="number">01</span> <span class="number">10</span>;</span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">   <span class="comment">#最大连接数</span></span><br><span class="line">   <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">   <span class="comment">#允许 Nginx 在已经得到一个新连接的通知时接收尽可能更多的连接</span></span><br><span class="line">   <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="section">http</span> &#123;</span><br><span class="line">   <span class="attribute">include</span>       mime.types;</span><br><span class="line">   <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">   <span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">   <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">   <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">   <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 启用 gzip 压缩</span></span><br><span class="line">   <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">   <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">   <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">   <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">   <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">8k</span>;</span><br><span class="line">   <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">   <span class="attribute">gzip_types</span> text/plain text/css</span><br><span class="line">              application/x-javascript text/xml</span><br><span class="line">              application/xml application/xml+rss</span><br><span class="line">              text/javascript application/javascript</span><br><span class="line">              image/svg+xml;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 包含虚拟主机配置文件</span></span><br><span class="line">   <span class="attribute">include</span> /usr/local/nginx/conf/vhost/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建虚拟主机配置文件目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/nginx/conf/vhost \</span><br><span class="line">&amp;&amp; vim /usr/local/nginx/conf/vhost/default.conf</span><br></pre></td></tr></table></figure><p><code>default.conf</code> 可参考如下配置</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line"> <span class="attribute">index</span>  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">server_name</span>  localhost;</span><br><span class="line"> <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"> <span class="attribute">error_log</span>  /var/log/nginx/default_error.log <span class="literal">warn</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="comment"># First attempt to serve request as file, then</span></span><br><span class="line">   <span class="comment"># as directory, then fall back to displaying a 404</span></span><br><span class="line">   <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line"> <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">  <span class="attribute">root</span>   /usr/local/nginx/html;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">   <span class="attribute">try_files</span> <span class="variable">$uri</span> /index.php =<span class="number">404</span>;</span><br><span class="line">    <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>;</span><br><span class="line">  <span class="comment"># fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">  <span class="comment"># 若使用下面这种，需确保目录要和fpm的配置文件中的listen一致</span></span><br><span class="line">  <span class="attribute">fastcgi_pass</span> /var/run/php/php7.<span class="number">2</span>-fpm.sock;</span><br><span class="line">  <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">  <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">  <span class="comment"># 或者像下面这样也是可以的</span></span><br><span class="line">  <span class="comment"># fastcgi_param SCRIPT_FILENAME $request_filename;</span></span><br><span class="line">  <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 禁止访问 .htxxx 文件</span></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ /\.ht</span> &#123;</span><br><span class="line">  <span class="attribute">deny</span> all;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|jpeg|png|bmp|swf|pdf|ico|docx|mp4|mp3|txt)$</span> &#123;</span><br><span class="line"><span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line"><span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ \.(js|css|html|json)?$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ \.(zip|rar|wav|mp3|csv|xls|xlsx)$</span> &#123;</span><br><span class="line">     <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">     <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -t # 校验配置文件</span><br></pre></td></tr></table></figure></li><li><p>创建 systemd 服务</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=https://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/var/run/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/lib/systemd/system/nginx.service</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure></li><li><p>开放端口</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li></ol><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><ol><li><p>依赖软件包安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libxml2-devel curl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gd gd2 gd-devel gd2-devel libwebp libwebp-devel php-devel libmemcached libmemcached-devel libevent-devel -y</span><br></pre></td></tr></table></figure></li><li><p>下载源代码</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp/ \</span><br><span class="line">&amp;&amp; wget https://cn2.php.net/distributions/php-7.2.10.tar.gz \</span><br><span class="line">&amp;&amp; tar -zxvf php-7.2.10.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd php-7.2.10/</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> php 7.2 不支持</span><br><span class="line">--enable-gd-native-ttf \</span><br><span class="line">  --with-mcrypt \</span><br><span class="line"><span class="meta">  #</span> 在phh7.1时，官方就开始建议用 ``penssl_*`` 系列函数代替 ``Mcrypt_*`` 系列的函数</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">   --prefix=/opt/php7.2.10 \</span><br><span class="line">   --exec-prefix=/opt/php7.2.10 \</span><br><span class="line">   --bindir=/opt/php7.2.10/bin \</span><br><span class="line">   --sbindir=/opt/php7.2.10/sbin \</span><br><span class="line">   --includedir=/opt/php7.2.10/include \</span><br><span class="line">   --libdir=/opt/php7.2.10/lib/php \</span><br><span class="line">   --mandir=/opt/php7.2.10/php/man \</span><br><span class="line">   --with-config-file-path=/opt/php7.2.10/etc \</span><br><span class="line">   --with-mhash \</span><br><span class="line">   --with-openssl \</span><br><span class="line">   --with-gd \</span><br><span class="line">   --with-iconv \</span><br><span class="line">   --with-zlib \</span><br><span class="line">   --enable-zip \</span><br><span class="line">   --enable-inline-optimization \</span><br><span class="line">   --disable-debug \</span><br><span class="line">   --disable-rpath \</span><br><span class="line">   --enable-shared \</span><br><span class="line">   --enable-xml \</span><br><span class="line">   --enable-bcmath \</span><br><span class="line">   --enable-shmop \</span><br><span class="line">   --enable-sysvsem \</span><br><span class="line">   --enable-mbregex \</span><br><span class="line">   --enable-mbstring \</span><br><span class="line">   --enable-exif \</span><br><span class="line">   --enable-ftp \</span><br><span class="line">   --enable-pcntl \</span><br><span class="line">   --enable-sockets \</span><br><span class="line">   --with-xmlrpc \</span><br><span class="line">   --enable-soap \</span><br><span class="line">   --without-pear \</span><br><span class="line">   --with-gettext \</span><br><span class="line">   --enable-session \</span><br><span class="line">   --with-curl \</span><br><span class="line">   --with-jpeg-dir \</span><br><span class="line">   --with-webp-dir \</span><br><span class="line">   --with-xpm-dir \</span><br><span class="line">   --with-freetype-dir=/usr/include/freetype2/freetype \</span><br><span class="line">   --enable-opcache \</span><br><span class="line">   --enable-mysqlnd \</span><br><span class="line">   --with-mysqli=mysqlnd \</span><br><span class="line">   --with-pdo-mysql=mysqlnd \</span><br><span class="line">   --enable-fpm \</span><br><span class="line">   --with-fpm-user=www \</span><br><span class="line">   --with-fpm-group=www</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j `grep processor /proc/cpuinfo | wc -l` &amp;&amp; make install &amp;&amp; make clean</span><br></pre></td></tr></table></figure></li><li><p>创建软链接</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /opt/php7.2.10 /usr/local/php</span><br></pre></td></tr></table></figure></li><li><p>注册环境变量</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e '\nexport PATH=/usr/local/php/bin:/usr/local/php/sbin:$PATH\n'  &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><p>配置php</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp/php-7.2.10/ \</span><br><span class="line">&amp;&amp; cp php.ini-development /usr/local/php/etc/php.ini \</span><br><span class="line">&amp;&amp; cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf \</span><br><span class="line">&amp;&amp; cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure></li><li><p>创建 systemd 服务</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/php.service</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=php</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line"> [Service]</span><br><span class="line">Type=forking</span><br><span class="line">   ExecStart=/usr/local/php/sbin/php-fpm</span><br><span class="line">   ExecReload=/bin/pkill php-fpm &amp;&amp; /usr/local/php/sbin/php-fpm</span><br><span class="line">   ExecStop=/bin/pkill php-fpm</span><br><span class="line">   PrivateTmp=true</span><br><span class="line"></span><br><span class="line"> [Install]</span><br><span class="line">   WantedBy=multi-user.target</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/lib/systemd/system/php.service</span><br><span class="line">systemctl start php.service </span><br><span class="line">systemctl enable php.service</span><br></pre></td></tr></table></figure><p> 其它命令</p><ul><li><p>启动 <code>php-fpm</code></p></li><li><p>重启 <code>kill -USR2 [php-fpm master 进程id]</code></p></li><li><p>停止 <code>kill [php-fpm master 进程id]</code></p></li><li><p>查看 php-fpm master 进程 id <code>ps -aux | grep php-fpm | grep master</code></p><p>Composer 安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line"> php -r "copy('https://install.phpcomposer.com/installer', 'composer-setup.php');"</span><br><span class="line"> php composer-setup.php</span><br><span class="line"> php -r "unlink('composer-setup.php');"</span><br><span class="line"> mv composer.phar /usr/local/bin/composer</span><br><span class="line"> composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure></li></ul><p>PHP 扩展安装(有两种方式安装，一种是使用 pecl ，另一种是下载源码编译安装)<br>方式一：使用 pecl 安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 安装 pecl</span><br><span class="line">   wget https://pear.php.net/go-pear.phar # 下载</span><br><span class="line">   php go-pear.phar</span><br><span class="line">   pecl version # 查看 pecl 版本</span><br><span class="line">   pecl channel-update pecl.php.net # 更新下仓库</span><br></pre></td></tr></table></figure><p> 使用 pecl 安装扩展(受网速影响可能会出现查询不到包，重试几次即可)</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pecl install redis</span><br><span class="line">pecl info redis</span><br><span class="line">pecl unisntall redis</span><br></pre></td></tr></table></figure><p> 也可以使用安装包</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://pecl.php.net/get/redis-4.1.1.tgz</span><br><span class="line">wget https://pecl.php.net/get/swoole-4.2.1.tgz</span><br><span class="line">wget https://pecl.php.net/get/memcached-3.0.4.tgz</span><br><span class="line">wget https://pecl.php.net/get/xdebug-2.6.1.tgz</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pecl install redis-4.1.1.tgz</span><br><span class="line">pecl install swoole-4.2.1.tgz</span><br><span class="line">pecl install memcached-3.0.4.tgz</span><br><span class="line">pecl install xdebug-2.6.1.tgz</span><br></pre></td></tr></table></figure><p> 修改PHP.ini</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/php/etc/php.ini</span><br></pre></td></tr></table></figure><p> 添加扩展到 <code>php.ini</code>,大概在908行<br> <strong>extension=redis</strong><br> <strong>extension=swoole</strong><br> <strong>extension=memcached</strong><br> <strong>zend_extension=xdebug</strong><br> <strong>xdebug.remote_enable=on</strong><br> 重启 PHP</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart php.service</span><br></pre></td></tr></table></figure><p> 方式二：下载源码编译安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp/ \</span><br><span class="line">&amp;&amp; git clone https://github.com/phpredis/phpredis.git \</span><br><span class="line">&amp;&amp; cd phpredis \</span><br><span class="line">&amp;&amp; /usr/local/php/bin/phpize \</span><br><span class="line">&amp;&amp; ./configure --with-php-config=/usr/local/php/bin/php-config \</span><br><span class="line">&amp;&amp; make &amp;&amp; make install &amp;&amp; make clean</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/php/etc/php.ini</span><br></pre></td></tr></table></figure><p> 添加扩展 <strong>extension=redis</strong> 到 <code>php.ini</code>,重启php-fpm</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart php.service</span><br></pre></td></tr></table></figure></li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol><li><p>安装前准备</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>更新软件源</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure></li><li><p>yum 方式安装(默认会安装最新版的mysql)</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure></li><li><p>服务管理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br><span class="line">systemctl enable mysqld.service</span><br><span class="line">systemctl status mysqld.service</span><br><span class="line">systemctl restart mysqld.service</span><br><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure></li><li><p>修改 root 密码<br> 先获取安装时的预设密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/mysqld.log | grep password</span><br></pre></td></tr></table></figure><p> 使用上一步获取到的密码进行 mysql 登录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p> 修改密码</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';</span><br></pre></td></tr></table></figure><p> 创建一个 dev 用户可以本地登录，并授权</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE USER 'dev'@'localhost' IDENTIFIED BY '新密码';</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'dev'@'localhost' WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p> 创建一个 dev 用户可以远程登录，并授权</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE USER 'dev'@'%' IDENTIFIED BY '新密码';</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'dev'@'%' WITH GRANT OPTION;</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p> 修改 my.cnf</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p> 添加以下内容到文件中</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br></pre></td></tr></table></figure><p> 重启mysqld 服务</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure><p> 检查服务</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -lntup | grep mysql</span><br></pre></td></tr></table></figure></li></ol><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ol><li><p>下载源码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp/ \</span><br><span class="line">&amp;&amp; wget https://download.redis.io/releases/redis-4.0.11.tar.gz \</span><br><span class="line">&amp;&amp; tar -xzvf redis-4.0.11.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-4.0.11/</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j `grep processor /proc/cpuinfo | wc -l` &amp;&amp; make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure></li><li><p>配置 Redis</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/redis/etc/</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis.conf /usr/local/redis/etc/</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/bin/</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis-benchmark redis-cli redis-server /usr/bin/</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "vm.overcommit_memory=1"&gt;&gt;/etc/sysctl.conf &amp;&amp; sysctl -p</span><br></pre></td></tr></table></figure><p>修改配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/redis/etc/redis.conf</span><br></pre></td></tr></table></figure><ul><li><p>daemonize yes<br>redis以守护进程的方式运行<br>no表示不以守护进程的方式运行(会占用一个终端)</p></li><li><p>timeout 300<br>客户端闲置多长时间后断开连接，默认为0关闭此功能</p></li><li><p>loglevel verbose<br>设置redis日志级别，默认级别：notice</p></li><li><p>requirepass redis密码<br>设置 redis 密码</p></li><li><p>port 6379<br>设置 redis 端口</p></li><li><p>logfile stdout<br>设置日志文件的输出方式,如果以守护进程的方式运行redis 默认:””<br>并且日志输出设置为stdout,那么日志信息就输出到/dev/null里面去了 </p></li><li><p>bind 127.0.0.1</p></li><li><p>注释掉该项，若需要远程访问</p></li></ul></li><li><p>添加环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e '\nexport PATH=/usr/local/redis/bin:$PATH\n'  &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</span><br></pre></td></tr></table></figure></li><li><p>创建 systemd 服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/redis.service</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">       Description=Redis</span><br><span class="line">       After=network.target</span><br><span class="line"></span><br><span class="line">   [Service]</span><br><span class="line">       Type=forking</span><br><span class="line">       ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf </span><br><span class="line">       ExecReload=/bin/pkill redis-server &amp;&amp; /usr/local/redis/bin/redis-server/usr/local/redis/etc/redis.conf </span><br><span class="line">       ExecStop=/bin/pkill redis-server</span><br><span class="line">       PrivateTmp=true</span><br><span class="line"></span><br><span class="line">   [Install]</span><br><span class="line">       WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/lib/systemd/system/redis.service</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start redis.service</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable redis.service</span><br></pre></td></tr></table></figure></li><li><p>测试redis登录<br> 方式一：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a redis密码</span><br></pre></td></tr></table></figure><p> 方式二：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auth redis密码</span><br></pre></td></tr></table></figure></li></ol><h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><ol><li><p>下载源码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp/ \</span><br><span class="line">&amp;&amp; wget https://nodejs.org/dist/v8.12.0/node-v8.12.0.tar.gz \</span><br><span class="line">&amp;&amp; tar -xzvf node-v8.12.0.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd node-v8.12.0 \</span><br><span class="line">&amp;&amp; ./configure --prefix=/opt/node8.12.0 \</span><br><span class="line">&amp;&amp; make -j `grep processor /proc/cpuinfo | wc -l` &amp;&amp; make install &amp;&amp; make clean</span><br></pre></td></tr></table></figure></li><li><p>创建软链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /opt/node8.12.0 /usr/local/node</span><br></pre></td></tr></table></figure></li><li><p>注册环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e '\nexport PATH=/usr/local/node/bin:$PATH\n'  &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo</span><br><span class="line">yum install -y yarn</span><br></pre></td></tr></table></figure><h2 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install memcached</span><br><span class="line">cat /etc/sysconfig/memcached</span><br><span class="line">systemctl start memcached</span><br><span class="line">systemctl enable memcached</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=11211/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>启动方式一：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">memcached -d -l 127.0.0.1 -p 11211 -m 150 -u root</span><br></pre></td></tr></table></figure><p>启动方式二：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">memcached -u memcached -p 11211 -m 64 -c 1024</span><br></pre></td></tr></table></figure><p>启动选项：<br>    -d 是启动一个守护进程；<br>    -m 是分配给Memcache使用的内存数量，单位是MB；<br>    -u 是运行Memcache的用户；<br>    -l 是监听的服务器IP地址，可以有多个地址；<br>    -p 是设置Memcache监听的端口，，最好是1024以上的端口；<br>    -c 是最大运行的并发连接数，默认是1024；<br>    -P 是设置保存Memcache的pid文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep memcached # 可以检查 memcached 是否在运行</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC 入门</title>
      <link href="/java/jdbc.html"/>
      <url>/java/jdbc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>处理 Java 应用程序中不同数据库的访问问题：可以通过它建立与数据库的连接；定义特定的客户端使之可以访问给定的数据库；提供一种能够读取、插入、更新和删除数据库中的数据项的机制；以及控制由不同SQL语句组成的事务。</p></blockquote><a id="more"></a><h2 id="JDBC-用法"><a href="#JDBC-用法" class="headerlink" title="JDBC 用法"></a>JDBC 用法</h2><ul><li>创建并建立与特定数据库的连接<ul><li>通过 <strong>Driver Manger</strong> 连接(<code>java.sql.DriveManager</code>)</li><li>通过 <strong>JDBC 数据源连接池</strong> 连接(<code>javax.sql.DataSource</code>)</li></ul></li><li>建立连接后使用 <code>java.sql.Connection</code> 执行 CRUD(create/read/update/delete)操作<ul><li>为了执行这些操作，可以使用 <code>java.sql.Statement</code> 对象或 <code>java.sql.PreparedStatement</code> 对象。预编译对象 <code>java.sql.PreparedStatement</code> 对于多次执行相同的语句效率会高一些，且预编译机制可以阻止 SQL 注入</li></ul></li></ul><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p><strong>通常情况下，JDBC 使用连接池来管理数据库连接。连接池有很多不同的实现方式，比如 C3P0 或 DBCP。数据库连接池是一组 JDBC 连接，当应用程序请求连接时，它会分配一个空闲连接；当应用中有任务终结时，它会释放相应的连接。</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>JDBC 在使用 Java 程序中的数据之前，JDBC 会将 Java 数据类型转换成相对应的 JDBC 数据类型，它们之间有一个默认的对应关系，能够保证在不同的数据库实现和驱动之间的一致性。</strong></p><table><thead><tr><th>SQL</th><th>JDBC/Java</th><th>setter</th><th>getter</th></tr></thead><tbody><tr><td>VARCHAR</td><td>java.lang.String</td><td>setString</td><td>getString</td></tr><tr><td>CHAR</td><td>java.lang.String</td><td>setString</td><td>getString</td></tr><tr><td>LONGVARCHAR</td><td>java.lang.String</td><td>setString</td><td>getString</td></tr><tr><td>BIT</td><td>boolean</td><td>setBoolean</td><td>getBoolean</td></tr><tr><td>NUMERIC</td><td>BigDecimal</td><td>setBigDecimal</td><td>getBigDecimal</td></tr><tr><td>TINYINT</td><td>byte</td><td>setByte</td><td>getByte</td></tr><tr><td>SMALLINT</td><td>short</td><td>setShort</td><td>getShort</td></tr><tr><td>INTEGER</td><td>int</td><td>setInt</td><td>getInt</td></tr><tr><td>BIGINT</td><td>long</td><td>setLong</td><td>getLong</td></tr><tr><td>REAL</td><td>float</td><td>setFloat</td><td>getFloat</td></tr><tr><td>FLOAT</td><td>float</td><td>setFloat</td><td>getFloat</td></tr><tr><td>DOUBLE</td><td>double</td><td>setDouble</td><td>getDouble</td></tr><tr><td>VARBINARY</td><td>byte[]</td><td>setBytes</td><td>getBytes</td></tr><tr><td>BINARY</td><td>byte[]</td><td>setBytes</td><td>getBytes</td></tr><tr><td>DATE</td><td>java.sql.Date</td><td>setDate</td><td>getDate</td></tr><tr><td>DATETIME</td><td>java.sql.Timestamp</td><td>setTimestamp</td><td>getTimestamp</td></tr><tr><td>TIMESTAMP</td><td>java.sql.Timestamp</td><td>setTimestamp</td><td>getTimestamp</td></tr><tr><td>CLOB</td><td>java.sql.Clob</td><td>setClob</td><td>getClob</td></tr><tr><td>BLOB</td><td>java.sql.Blob</td><td>setBlob</td><td>getBlob</td></tr><tr><td>ARRAY</td><td>java.sql.Array</td><td>setARRAY</td><td>getARRAY</td></tr><tr><td>REF</td><td>java.sql.Ref</td><td>setRef</td><td>getRef</td></tr><tr><td>STRUCT</td><td>java.sql.Struct</td><td>setStruct</td><td>getStruct</td></tr></tbody></table><p><strong>SQL 和 Java 对于空值（null）有不同的处理方式。在使用SQL处理一些Java 中的空值时，我们最好能够遵循一些最佳实践，比如避免使用基本数据类型，因为它们默认值不能为空而是会依据具体类型设定默认值，比如int型默认值为0、布尔型（boolean）默认值为false，建议使用包装类</strong></p><h2 id="SQL-日期类型的处理"><a href="#SQL-日期类型的处理" class="headerlink" title="SQL 日期类型的处理"></a>SQL 日期类型的处理</h2><ol><li><p>字段类型为 <code>Date</code><br> 使用 <code>java.sql.Date.valueOf(java.lang.String)</code> 格式是 YYYY-MM-dd</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ps.setDate(<span class="number">2</span>, java.sql.Date.valueOf(<span class="string">"2019-03-04"</span>));</span><br><span class="line"><span class="comment">// 设置为当前日期</span></span><br><span class="line"><span class="comment">// 方式一: </span></span><br><span class="line">ps.setDate(<span class="number">2</span>, <span class="keyword">new</span> java.sql.Date(System.currentTimeMillis()));</span><br><span class="line"><span class="comment">// 方式二: </span></span><br><span class="line">ps.setDate(<span class="number">2</span>, <span class="keyword">new</span> java.sql.Date(<span class="keyword">new</span> Date().getTime());</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>字段类型为 <code>TIMESTAMP</code> 或 <code>DATETIME</code><br> 使用 <code>java.sql.Timestamp.valueOf(java.lang.String)</code></p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    ps.setTimestamp(<span class="number">2</span>, java.sql.Timestamp.valueOf(<span class="string">"2019-03-04 13:30:00"</span>);</span><br><span class="line">    <span class="comment">// 设置为当前时间</span></span><br><span class="line">      <span class="comment">// 方式一:</span></span><br><span class="line">    ps.setTimestamp(<span class="number">2</span>, <span class="keyword">new</span> java.sql.Timestamp(<span class="keyword">new</span> Date().getTime()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二:</span></span><br><span class="line">    ps.setTimestamp(<span class="number">2</span>, <span class="keyword">new</span> java.sql.Timestamp(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 8 </span></span><br><span class="line">    ps.setTimestamp(<span class="number">2</span>, java.sql.Timestamp.from(java.time.Instant.now()));</span><br><span class="line">    ps.setTimestamp(<span class="number">2</span>, java.sql.Timestamp.valueOf(java.time.LocalDateTime.now()));</span><br><span class="line">    </span><br><span class="line">    LocalDate localDate = LocalDate.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">myPreparedStatement.setObject(<span class="number">1</span>, localDate);</span><br></pre></td></tr></table></figure></li></ol><h2 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h2><p><strong>JDBC 驱动管理器 <code>java.sql.DriverManager</code> 的主要功能就是：获取当前可用的驱动列表；处理特定的的驱动程序和数据库之间的连接。</strong></p><h3 id="注册驱动程序"><a href="#注册驱动程序" class="headerlink" title="注册驱动程序"></a>注册驱动程序</h3><ul><li>registerDriver() : 需要保证驱动程序在编译时就是可用的</li><li><strong>Class.forName() 推荐使用 : 不需要驱动程序在编译时是可用的</strong></li></ul><p><img src="https://images.csthink.com/Carbonize%202019-04-13%20at%2011.25.20.png" alt="注册驱动程序"></p><h3 id="JDBC-封装类"><a href="#JDBC-封装类" class="headerlink" title="JDBC 封装类"></a>JDBC 封装类</h3><p><img src="https://images.csthink.com/Carbonize%202019-04-13%20at%2012.20.40.png" alt="JDBC 封装类"></p><p><code>jdbc.properties</code> 文件放在classpath 路径下即可(resources 目录)，内容示例如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DRIVER_CLASS=com.mysql.jdbc.Driver</span><br><span class="line">URL=jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;amp;characterEncoding=utf8&amp;useSSL=false</span><br><span class="line">USERNAME=root</span><br><span class="line">PASSWORD=root</span><br></pre></td></tr></table></figure><h3 id="C3P0数据库连接池封装类"><a href="#C3P0数据库连接池封装类" class="headerlink" title="C3P0数据库连接池封装类"></a>C3P0数据库连接池封装类</h3><p><img src="https://images.csthink.com/Carbonize%202019-04-13%20at%2012.23.23.png" alt="C3P0数据库连接池封装类"></p><p><code>c3p0-config.xml</code> 配置文件放置在classpath(resources目录)，内容示例如下</p><p><img src="https://images.csthink.com/Carbonize%202019-04-13%20at%2012.24.28.png" alt="c3p0-config.xml"></p><p>测试类代码<br><img src="https://images.csthink.com/Carbonize%202019-04-13%20at%2012.28.43.png" alt="测试类代码"></p><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>示例代码托管在了 github: <a href="https://github.com/csthink/JDBC" target="_blank" rel="noopener">https://github.com/csthink/JDBC</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
